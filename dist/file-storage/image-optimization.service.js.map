{"version":3,"sources":["../../src/file-storage/image-optimization.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport sharp from 'sharp';\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport * as glob from 'glob';\n\nexport interface OptimizationOptions {\n  quality?: number; // 1-100, default 70\n  maxWidth?: number; // default 1920\n  maxHeight?: number; // default 1080\n  format?: 'jpeg' | 'png' | 'webp' | 'avif' | 'svg'; // default 'jpeg'\n  progressive?: boolean; // default true\n}\n\nexport interface OptimizationResult {\n  originalSize: number;\n  optimizedSize: number;\n  reductionPercentage: number;\n  originalPath: string;\n  optimizedPath: string;\n  backupPath: string;\n  success: boolean;\n  error?: string;\n}\n\n@Injectable()\nexport class ImageOptimizationService {\n  private readonly logger = new Logger(ImageOptimizationService.name);\n  private readonly defaultOptions: OptimizationOptions = {\n    quality: 50, // Default quality (will be overridden based on file size)\n    format: 'jpeg',\n    progressive: true,\n  };\n\n  /**\n   * Optimize a single image file\n   */\n  async optimizeImage(\n    inputPath: string,\n    outputPath?: string,\n    options: OptimizationOptions = {},\n  ): Promise<OptimizationResult> {\n    // Start with default options\n    const opts = { ...this.defaultOptions, ...options };\n\n    // Create backup path - preserve directory structure\n    const relativePath = path.relative('uploads', inputPath);\n    const backupPath = path.join('uploads_backup', relativePath);\n\n    // Create optimized file path in separate folder\n    const optimizedPath = path.join('uploads_optimized', relativePath);\n    const finalOutputPath = outputPath || optimizedPath;\n\n    try {\n      // Create backup directory and copy original file\n      await fs.ensureDir(path.dirname(backupPath));\n      await fs.copy(inputPath, backupPath);\n\n      // Get original file stats\n      const originalStats = await fs.stat(inputPath);\n      const originalSize = originalStats.size;\n\n      // Check if this is a sizechart or measure image - skip compression for these\n      const isSizechartOrMeasure =\n        inputPath.includes('sizechart') || inputPath.includes('measure');\n\n      if (isSizechartOrMeasure) {\n        // Don't compress sizechart or measure images - keep original quality\n        opts.quality = 100;\n        this.logger.log(\n          `Skipping compression for ${path.basename(inputPath)} (sizechart/measure)`,\n        );\n      } else {\n        // Dynamically set quality based on file size\n        // If file is less than 150KB, use 50% quality\n        // If file is 150KB or larger, use 30% quality\n        const sizeInKB = originalSize / 1024;\n        if (!options.quality) {\n          // Only override if not explicitly set\n          if (sizeInKB < 150) {\n            opts.quality = 50; // Moderate compression for smaller files\n          } else {\n            opts.quality = 30; // Higher compression for larger files\n          }\n        }\n      }\n\n      // Read the image\n      const image = sharp(inputPath);\n\n      // Get image metadata\n      const metadata = await image.metadata();\n\n      // Keep original dimensions - only compress, don't resize\n      const { width, height } = metadata;\n\n      // Apply transformations without resizing\n      let processedImage = image;\n\n      // Apply format-specific optimizations\n      switch (opts.format) {\n        case 'jpeg':\n          processedImage = processedImage.jpeg({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            mozjpeg: true,\n          });\n          break;\n        case 'png':\n          processedImage = processedImage.png({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            compressionLevel: 9,\n          });\n          break;\n        case 'webp':\n          processedImage = processedImage.webp({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        case 'avif':\n          processedImage = processedImage.avif({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        // Note: Sharp does not support SVG output. Skipping 'svg' case.\n      }\n\n      // Ensure output directory exists\n      await fs.ensureDir(path.dirname(finalOutputPath));\n\n      // Save optimized image to optimized folder\n      await processedImage.toFile(finalOutputPath);\n\n      // Get optimized file stats\n      const optimizedStats = await fs.stat(finalOutputPath);\n      const optimizedSize = optimizedStats.size;\n\n      const reductionPercentage =\n        ((originalSize - optimizedSize) / originalSize) * 100;\n\n      this.logger.log(\n        `Optimized: ${path.basename(inputPath)} - ${originalSize}KB → ${optimizedSize}KB (${reductionPercentage.toFixed(1)}% reduction)`,\n      );\n\n      // No need to replace original - optimized file is saved separately\n\n      return {\n        originalSize,\n        optimizedSize,\n        reductionPercentage,\n        originalPath: inputPath,\n        optimizedPath: finalOutputPath,\n        backupPath: backupPath,\n        success: true,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to optimize ${inputPath}: ${error.message}`);\n\n      // No cleanup needed - optimized files are saved separately\n\n      return {\n        originalSize: 0,\n        optimizedSize: 0,\n        reductionPercentage: 0,\n        originalPath: inputPath,\n        optimizedPath: finalOutputPath,\n        backupPath: backupPath,\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Optimize a buffer (for new uploads)\n   */\n  async optimizeBuffer(\n    buffer: Buffer,\n    options: OptimizationOptions = {},\n  ): Promise<Buffer> {\n    const opts = { ...this.defaultOptions, ...options };\n\n    try {\n      let processedImage = sharp(buffer);\n\n      // Get image metadata\n      const metadata = await processedImage.metadata();\n\n      // Keep original dimensions - only compress, don't resize\n      const { width, height } = metadata;\n\n      // Apply transformations without resizing\n      processedImage = processedImage;\n\n      // Apply format-specific optimizations\n      switch (opts.format) {\n        case 'jpeg':\n          processedImage = processedImage.jpeg({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            mozjpeg: true,\n          });\n          break;\n        case 'png':\n          processedImage = processedImage.png({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            compressionLevel: 9,\n          });\n          break;\n        case 'webp':\n          processedImage = processedImage.webp({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        case 'avif':\n          processedImage = processedImage.avif({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n      }\n\n      return await processedImage.toBuffer();\n    } catch (error) {\n      this.logger.error(`Failed to optimize buffer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Batch optimize all images in a directory\n   */\n  async optimizeDirectory(\n    directoryPath: string,\n    options: OptimizationOptions = {},\n    recursive = true,\n  ): Promise<OptimizationResult[]> {\n    const results: OptimizationResult[] = [];\n\n    try {\n      // Use fs-extra to find all image files recursively\n      const findImageFiles = async (dir: string): Promise<string[]> => {\n        const files: string[] = [];\n        const items = await fs.readdir(dir);\n\n        for (const item of items) {\n          const fullPath = path.join(dir, item);\n          const stat = await fs.stat(fullPath);\n\n          if (stat.isDirectory() && recursive) {\n            const subFiles = await findImageFiles(fullPath);\n            files.push(...subFiles);\n          } else if (stat.isFile()) {\n            const ext = path.extname(item).toLowerCase();\n            if (['.jpg', '.jpeg', '.png', '.webp'].includes(ext)) {\n              files.push(fullPath);\n            }\n          }\n        }\n\n        return files;\n      };\n\n      const files = await findImageFiles(directoryPath);\n      this.logger.log(\n        `Found ${files.length} images to optimize in ${directoryPath}`,\n      );\n\n      for (const file of files) {\n        const result = await this.optimizeImage(file, undefined, options);\n        results.push(result);\n      }\n\n      // Log summary\n      const successful = results.filter((r) => r.success);\n      const totalOriginalSize = successful.reduce(\n        (sum, r) => sum + r.originalSize,\n        0,\n      );\n      const totalOptimizedSize = successful.reduce(\n        (sum, r) => sum + r.optimizedSize,\n        0,\n      );\n      const averageReduction =\n        successful.length > 0\n          ? successful.reduce((sum, r) => sum + r.reductionPercentage, 0) /\n            successful.length\n          : 0;\n\n      this.logger.log(\n        `Batch optimization complete: ${successful.length}/${files.length} successful, ` +\n          `${(totalOriginalSize / 1024).toFixed(1)}KB → ${(totalOptimizedSize / 1024).toFixed(1)}KB ` +\n          `(${averageReduction.toFixed(1)}% average reduction)`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to optimize directory ${directoryPath}: ${error.message}`,\n      );\n    }\n\n    return results;\n  }\n\n  /**\n   * Optimize all images in the uploads folder\n   */\n  async optimizeAllUploads(\n    options: OptimizationOptions = {},\n  ): Promise<OptimizationResult[]> {\n    const uploadsPath = 'uploads';\n\n    if (!(await fs.pathExists(uploadsPath))) {\n      this.logger.warn('Uploads directory does not exist');\n      return [];\n    }\n\n    this.logger.log('Starting optimization of all uploads...');\n    return await this.optimizeDirectory(uploadsPath, options, true);\n  }\n\n  /**\n   * Get supported image formats\n   */\n  getSupportedFormats(): string[] {\n    return ['jpg', 'jpeg', 'png', 'webp', 'avif', 'JPG', 'JPEG', 'PNG', 'WEBP'];\n  }\n\n  /**\n   * Check if a file is a supported image format\n   */\n  isSupportedImage(filename: string): boolean {\n    const ext = path.extname(filename).toLowerCase().slice(1);\n    return this.getSupportedFormats().includes(ext);\n  }\n}\n"],"names":["ImageOptimizationService","optimizeImage","inputPath","outputPath","options","opts","defaultOptions","relativePath","path","relative","backupPath","join","optimizedPath","finalOutputPath","fs","ensureDir","dirname","copy","originalStats","stat","originalSize","size","isSizechartOrMeasure","includes","quality","logger","log","basename","sizeInKB","image","sharp","metadata","width","height","processedImage","format","jpeg","progressive","mozjpeg","png","compressionLevel","webp","effort","avif","toFile","optimizedStats","optimizedSize","reductionPercentage","toFixed","originalPath","success","error","message","optimizeBuffer","buffer","toBuffer","optimizeDirectory","directoryPath","recursive","results","findImageFiles","dir","files","items","readdir","item","fullPath","isDirectory","subFiles","push","isFile","ext","extname","toLowerCase","length","file","result","undefined","successful","filter","r","totalOriginalSize","reduce","sum","totalOptimizedSize","averageReduction","optimizeAllUploads","uploadsPath","pathExists","warn","getSupportedFormats","isSupportedImage","filename","slice","Logger","name"],"mappings":"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"}