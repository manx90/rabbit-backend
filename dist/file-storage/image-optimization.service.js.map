{"version":3,"sources":["../../src/file-storage/image-optimization.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport sharp from 'sharp';\nimport * as fs from 'fs-extra';\nimport * as path from 'path';\nimport * as glob from 'glob';\n\nexport interface OptimizationOptions {\n  quality?: number; // 1-100, default 70\n  maxWidth?: number; // default 1920\n  maxHeight?: number; // default 1080\n  format?: 'jpeg' | 'png' | 'webp' | 'avif' | 'svg'; // default 'jpeg'\n  progressive?: boolean; // default true\n}\n\nexport interface OptimizationResult {\n  originalSize: number;\n  optimizedSize: number;\n  reductionPercentage: number;\n  originalPath: string;\n  optimizedPath: string;\n  backupPath: string;\n  success: boolean;\n  error?: string;\n}\n\n@Injectable()\nexport class ImageOptimizationService {\n  private readonly logger = new Logger(ImageOptimizationService.name);\n  private readonly isProduction = process.env.NODE_ENV === 'production';\n  private readonly defaultOptions: OptimizationOptions = {\n    quality: 50, // Default quality (will be overridden based on file size)\n    format: 'jpeg',\n    progressive: true,\n  };\n\n  /**\n   * Optimize a single image file\n   */\n  async optimizeImage(\n    inputPath: string,\n    outputPath?: string,\n    options: OptimizationOptions = {},\n  ): Promise<OptimizationResult> {\n    // In production mode, skip heavy optimization to save memory\n    if (this.isProduction) {\n      this.logger.log(\n        `Skipping image optimization in production mode for: ${inputPath}`,\n      );\n      return {\n        originalSize: 0,\n        optimizedSize: 0,\n        reductionPercentage: 0,\n        originalPath: inputPath,\n        optimizedPath: inputPath,\n        backupPath: inputPath,\n        success: true,\n      };\n    }\n\n    // Start with default options\n    const opts = { ...this.defaultOptions, ...options };\n\n    // Create backup path - preserve directory structure\n    const relativePath = path.relative('uploads', inputPath);\n    const backupPath = path.join('uploads_backup', relativePath);\n\n    // Create optimized file path in separate folder\n    const optimizedPath = path.join('uploads_optimized', relativePath);\n    const finalOutputPath = outputPath || optimizedPath;\n\n    try {\n      // Create backup directory and copy original file\n      await fs.ensureDir(path.dirname(backupPath));\n      await fs.copy(inputPath, backupPath);\n\n      // Get original file stats\n      const originalStats = await fs.stat(inputPath);\n      const originalSize = originalStats.size;\n\n      // Check if this is a sizechart or measure image - skip compression for these\n      const isSizechartOrMeasure =\n        inputPath.includes('sizechart') || inputPath.includes('measure');\n\n      if (isSizechartOrMeasure) {\n        // Don't compress sizechart or measure images - keep original quality\n        opts.quality = 100;\n        this.logger.log(\n          `Skipping compression for ${path.basename(inputPath)} (sizechart/measure)`,\n        );\n      } else {\n        // Dynamically set quality based on file size\n        // If file is less than 150KB, use 50% quality\n        // If file is 150KB or larger, use 30% quality\n        const sizeInKB = originalSize / 1024;\n        if (!options.quality) {\n          // Only override if not explicitly set\n          if (sizeInKB < 150) {\n            opts.quality = 50; // Moderate compression for smaller files\n          } else {\n            opts.quality = 30; // Higher compression for larger files\n          }\n        }\n      }\n\n      // Read the image\n      const image = sharp(inputPath);\n\n      // Get image metadata\n      const metadata = await image.metadata();\n\n      // Keep original dimensions - only compress, don't resize\n      const { width, height } = metadata;\n\n      // Apply transformations without resizing\n      let processedImage = image;\n\n      // Apply format-specific optimizations\n      switch (opts.format) {\n        case 'jpeg':\n          processedImage = processedImage.jpeg({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            mozjpeg: true,\n          });\n          break;\n        case 'png':\n          processedImage = processedImage.png({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            compressionLevel: 9,\n          });\n          break;\n        case 'webp':\n          processedImage = processedImage.webp({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        case 'avif':\n          processedImage = processedImage.avif({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        // Note: Sharp does not support SVG output. Skipping 'svg' case.\n      }\n\n      // Ensure output directory exists\n      await fs.ensureDir(path.dirname(finalOutputPath));\n\n      // Save optimized image to optimized folder\n      await processedImage.toFile(finalOutputPath);\n\n      // Get optimized file stats\n      const optimizedStats = await fs.stat(finalOutputPath);\n      const optimizedSize = optimizedStats.size;\n\n      const reductionPercentage =\n        ((originalSize - optimizedSize) / originalSize) * 100;\n\n      this.logger.log(\n        `Optimized: ${path.basename(inputPath)} - ${originalSize}KB → ${optimizedSize}KB (${reductionPercentage.toFixed(1)}% reduction)`,\n      );\n\n      // No need to replace original - optimized file is saved separately\n\n      return {\n        originalSize,\n        optimizedSize,\n        reductionPercentage,\n        originalPath: inputPath,\n        optimizedPath: finalOutputPath,\n        backupPath: backupPath,\n        success: true,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to optimize ${inputPath}: ${error.message}`);\n\n      // No cleanup needed - optimized files are saved separately\n\n      return {\n        originalSize: 0,\n        optimizedSize: 0,\n        reductionPercentage: 0,\n        originalPath: inputPath,\n        optimizedPath: finalOutputPath,\n        backupPath: backupPath,\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  /**\n   * Optimize a buffer (for new uploads)\n   */\n  async optimizeBuffer(\n    buffer: Buffer,\n    options: OptimizationOptions = {},\n  ): Promise<Buffer> {\n    const opts = { ...this.defaultOptions, ...options };\n\n    try {\n      let processedImage = sharp(buffer);\n\n      // Get image metadata\n      const metadata = await processedImage.metadata();\n\n      // Keep original dimensions - only compress, don't resize\n      const { width, height } = metadata;\n\n      // Apply transformations without resizing\n      processedImage = processedImage;\n\n      // Apply format-specific optimizations\n      switch (opts.format) {\n        case 'jpeg':\n          processedImage = processedImage.jpeg({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            mozjpeg: true,\n          });\n          break;\n        case 'png':\n          processedImage = processedImage.png({\n            quality: opts.quality,\n            progressive: opts.progressive,\n            compressionLevel: 9,\n          });\n          break;\n        case 'webp':\n          processedImage = processedImage.webp({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n        case 'avif':\n          processedImage = processedImage.avif({\n            quality: opts.quality,\n            effort: 6,\n          });\n          break;\n      }\n\n      return await processedImage.toBuffer();\n    } catch (error) {\n      this.logger.error(`Failed to optimize buffer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Batch optimize all images in a directory\n   */\n  async optimizeDirectory(\n    directoryPath: string,\n    options: OptimizationOptions = {},\n    recursive = true,\n  ): Promise<OptimizationResult[]> {\n    const results: OptimizationResult[] = [];\n\n    try {\n      // Use fs-extra to find all image files recursively\n      const findImageFiles = async (dir: string): Promise<string[]> => {\n        const files: string[] = [];\n        const items = await fs.readdir(dir);\n\n        for (const item of items) {\n          const fullPath = path.join(dir, item);\n          const stat = await fs.stat(fullPath);\n\n          if (stat.isDirectory() && recursive) {\n            const subFiles = await findImageFiles(fullPath);\n            files.push(...subFiles);\n          } else if (stat.isFile()) {\n            const ext = path.extname(item).toLowerCase();\n            if (['.jpg', '.jpeg', '.png', '.webp'].includes(ext)) {\n              files.push(fullPath);\n            }\n          }\n        }\n\n        return files;\n      };\n\n      const files = await findImageFiles(directoryPath);\n      this.logger.log(\n        `Found ${files.length} images to optimize in ${directoryPath}`,\n      );\n\n      for (const file of files) {\n        const result = await this.optimizeImage(file, undefined, options);\n        results.push(result);\n      }\n\n      // Log summary\n      const successful = results.filter((r) => r.success);\n      const totalOriginalSize = successful.reduce(\n        (sum, r) => sum + r.originalSize,\n        0,\n      );\n      const totalOptimizedSize = successful.reduce(\n        (sum, r) => sum + r.optimizedSize,\n        0,\n      );\n      const averageReduction =\n        successful.length > 0\n          ? successful.reduce((sum, r) => sum + r.reductionPercentage, 0) /\n            successful.length\n          : 0;\n\n      this.logger.log(\n        `Batch optimization complete: ${successful.length}/${files.length} successful, ` +\n          `${(totalOriginalSize / 1024).toFixed(1)}KB → ${(totalOptimizedSize / 1024).toFixed(1)}KB ` +\n          `(${averageReduction.toFixed(1)}% average reduction)`,\n      );\n    } catch (error) {\n      this.logger.error(\n        `Failed to optimize directory ${directoryPath}: ${error.message}`,\n      );\n    }\n\n    return results;\n  }\n\n  /**\n   * Optimize all images in the uploads folder\n   */\n  async optimizeAllUploads(\n    options: OptimizationOptions = {},\n  ): Promise<OptimizationResult[]> {\n    const uploadsPath = 'uploads';\n\n    if (!(await fs.pathExists(uploadsPath))) {\n      this.logger.warn('Uploads directory does not exist');\n      return [];\n    }\n\n    this.logger.log('Starting optimization of all uploads...');\n    return await this.optimizeDirectory(uploadsPath, options, true);\n  }\n\n  /**\n   * Get supported image formats\n   */\n  getSupportedFormats(): string[] {\n    return ['jpg', 'jpeg', 'png', 'webp', 'avif', 'JPG', 'JPEG', 'PNG', 'WEBP'];\n  }\n\n  /**\n   * Check if a file is a supported image format\n   */\n  isSupportedImage(filename: string): boolean {\n    const ext = path.extname(filename).toLowerCase().slice(1);\n    return this.getSupportedFormats().includes(ext);\n  }\n}\n"],"names":["ImageOptimizationService","optimizeImage","inputPath","outputPath","options","isProduction","logger","log","originalSize","optimizedSize","reductionPercentage","originalPath","optimizedPath","backupPath","success","opts","defaultOptions","relativePath","path","relative","join","finalOutputPath","fs","ensureDir","dirname","copy","originalStats","stat","size","isSizechartOrMeasure","includes","quality","basename","sizeInKB","image","sharp","metadata","width","height","processedImage","format","jpeg","progressive","mozjpeg","png","compressionLevel","webp","effort","avif","toFile","optimizedStats","toFixed","error","message","optimizeBuffer","buffer","toBuffer","optimizeDirectory","directoryPath","recursive","results","findImageFiles","dir","files","items","readdir","item","fullPath","isDirectory","subFiles","push","isFile","ext","extname","toLowerCase","length","file","result","undefined","successful","filter","r","totalOriginalSize","reduce","sum","totalOptimizedSize","averageReduction","optimizeAllUploads","uploadsPath","pathExists","warn","getSupportedFormats","isSupportedImage","filename","slice","Logger","name","process","env","NODE_ENV"],"mappings":"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"}