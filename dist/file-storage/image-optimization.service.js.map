{"version":3,"sources":["../../src/file-storage/image-optimization.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\r\nimport * as sharp from 'sharp';\r\nimport * as fs from 'fs-extra';\r\nimport * as path from 'path';\r\nimport * as glob from 'glob';\r\n\r\nexport interface OptimizationOptions {\r\n  quality?: number; // 1-100, default 70\r\n  maxWidth?: number; // default 1920\r\n  maxHeight?: number; // default 1080\r\n  format?: 'jpeg' | 'png' | 'webp' | 'avif'; // default 'jpeg'\r\n  progressive?: boolean; // default true\r\n}\r\n\r\nexport interface OptimizationResult {\r\n  originalSize: number;\r\n  optimizedSize: number;\r\n  reductionPercentage: number;\r\n  originalPath: string;\r\n  optimizedPath: string;\r\n  backupPath: string;\r\n  success: boolean;\r\n  error?: string;\r\n}\r\n\r\n@Injectable()\r\nexport class ImageOptimizationService {\r\n  private readonly logger = new Logger(ImageOptimizationService.name);\r\n  private readonly defaultOptions: OptimizationOptions = {\r\n    quality: 70, // This is the main setting for file size reduction\r\n    format: 'jpeg',\r\n    progressive: true,\r\n  };\r\n\r\n  /**\r\n   * Optimize a single image file\r\n   */\r\n  async optimizeImage(\r\n    inputPath: string,\r\n    outputPath?: string,\r\n    options: OptimizationOptions = {},\r\n  ): Promise<OptimizationResult> {\r\n    const opts = { ...this.defaultOptions, ...options };\r\n\r\n    // Create backup path - preserve directory structure\r\n    const relativePath = path.relative('uploads', inputPath);\r\n    const backupPath = path.join('uploads_backup', relativePath);\r\n\r\n    // Create optimized file path in separate folder\r\n    const optimizedPath = path.join('uploads_optimized', relativePath);\r\n    const finalOutputPath = outputPath || optimizedPath;\r\n\r\n    try {\r\n      // Create backup directory and copy original file\r\n      await fs.ensureDir(path.dirname(backupPath));\r\n      await fs.copy(inputPath, backupPath);\r\n\r\n      // Get original file stats\r\n      const originalStats = await fs.stat(inputPath);\r\n      const originalSize = originalStats.size;\r\n\r\n      // Read the image\r\n      const image = sharp(inputPath);\r\n\r\n      // Get image metadata\r\n      const metadata = await image.metadata();\r\n\r\n      // Keep original dimensions - only compress, don't resize\r\n      const { width, height } = metadata;\r\n\r\n      // Apply transformations without resizing\r\n      let processedImage = image;\r\n\r\n      // Apply format-specific optimizations\r\n      switch (opts.format) {\r\n        case 'jpeg':\r\n          processedImage = processedImage.jpeg({\r\n            quality: opts.quality,\r\n            progressive: opts.progressive,\r\n            mozjpeg: true,\r\n          });\r\n          break;\r\n        case 'png':\r\n          processedImage = processedImage.png({\r\n            quality: opts.quality,\r\n            progressive: opts.progressive,\r\n            compressionLevel: 9,\r\n          });\r\n          break;\r\n        case 'webp':\r\n          processedImage = processedImage.webp({\r\n            quality: opts.quality,\r\n            effort: 6,\r\n          });\r\n          break;\r\n        case 'avif':\r\n          processedImage = processedImage.avif({\r\n            quality: opts.quality,\r\n            effort: 6,\r\n          });\r\n          break;\r\n      }\r\n\r\n      // Ensure output directory exists\r\n      await fs.ensureDir(path.dirname(finalOutputPath));\r\n\r\n      // Save optimized image to optimized folder\r\n      await processedImage.toFile(finalOutputPath);\r\n\r\n      // Get optimized file stats\r\n      const optimizedStats = await fs.stat(finalOutputPath);\r\n      const optimizedSize = optimizedStats.size;\r\n\r\n      const reductionPercentage =\r\n        ((originalSize - optimizedSize) / originalSize) * 100;\r\n\r\n      this.logger.log(\r\n        `Optimized: ${path.basename(inputPath)} - ${originalSize}KB → ${optimizedSize}KB (${reductionPercentage.toFixed(1)}% reduction)`,\r\n      );\r\n\r\n      // No need to replace original - optimized file is saved separately\r\n\r\n      return {\r\n        originalSize,\r\n        optimizedSize,\r\n        reductionPercentage,\r\n        originalPath: inputPath,\r\n        optimizedPath: finalOutputPath,\r\n        backupPath: backupPath,\r\n        success: true,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error(`Failed to optimize ${inputPath}: ${error.message}`);\r\n\r\n      // No cleanup needed - optimized files are saved separately\r\n\r\n      return {\r\n        originalSize: 0,\r\n        optimizedSize: 0,\r\n        reductionPercentage: 0,\r\n        originalPath: inputPath,\r\n        optimizedPath: finalOutputPath,\r\n        backupPath: backupPath,\r\n        success: false,\r\n        error: error.message,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize a buffer (for new uploads)\r\n   */\r\n  async optimizeBuffer(\r\n    buffer: Buffer,\r\n    options: OptimizationOptions = {},\r\n  ): Promise<Buffer> {\r\n    const opts = { ...this.defaultOptions, ...options };\r\n\r\n    try {\r\n      let processedImage = sharp(buffer);\r\n\r\n      // Get image metadata\r\n      const metadata = await processedImage.metadata();\r\n\r\n      // Keep original dimensions - only compress, don't resize\r\n      const { width, height } = metadata;\r\n\r\n      // Apply transformations without resizing\r\n      processedImage = processedImage;\r\n\r\n      // Apply format-specific optimizations\r\n      switch (opts.format) {\r\n        case 'jpeg':\r\n          processedImage = processedImage.jpeg({\r\n            quality: opts.quality,\r\n            progressive: opts.progressive,\r\n            mozjpeg: true,\r\n          });\r\n          break;\r\n        case 'png':\r\n          processedImage = processedImage.png({\r\n            quality: opts.quality,\r\n            progressive: opts.progressive,\r\n            compressionLevel: 9,\r\n          });\r\n          break;\r\n        case 'webp':\r\n          processedImage = processedImage.webp({\r\n            quality: opts.quality,\r\n            effort: 6,\r\n          });\r\n          break;\r\n        case 'avif':\r\n          processedImage = processedImage.avif({\r\n            quality: opts.quality,\r\n            effort: 6,\r\n          });\r\n          break;\r\n      }\r\n\r\n      return await processedImage.toBuffer();\r\n    } catch (error) {\r\n      this.logger.error(`Failed to optimize buffer: ${error.message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Batch optimize all images in a directory\r\n   */\r\n  async optimizeDirectory(\r\n    directoryPath: string,\r\n    options: OptimizationOptions = {},\r\n    recursive = true,\r\n  ): Promise<OptimizationResult[]> {\r\n    const results: OptimizationResult[] = [];\r\n\r\n    try {\r\n      // Use fs-extra to find all image files recursively\r\n      const findImageFiles = async (dir: string): Promise<string[]> => {\r\n        const files: string[] = [];\r\n        const items = await fs.readdir(dir);\r\n\r\n        for (const item of items) {\r\n          const fullPath = path.join(dir, item);\r\n          const stat = await fs.stat(fullPath);\r\n\r\n          if (stat.isDirectory() && recursive) {\r\n            const subFiles = await findImageFiles(fullPath);\r\n            files.push(...subFiles);\r\n          } else if (stat.isFile()) {\r\n            const ext = path.extname(item).toLowerCase();\r\n            if (['.jpg', '.jpeg', '.png', '.webp'].includes(ext)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n\r\n        return files;\r\n      };\r\n\r\n      const files = await findImageFiles(directoryPath);\r\n      this.logger.log(\r\n        `Found ${files.length} images to optimize in ${directoryPath}`,\r\n      );\r\n\r\n      for (const file of files) {\r\n        const result = await this.optimizeImage(file, undefined, options);\r\n        results.push(result);\r\n      }\r\n\r\n      // Log summary\r\n      const successful = results.filter((r) => r.success);\r\n      const totalOriginalSize = successful.reduce(\r\n        (sum, r) => sum + r.originalSize,\r\n        0,\r\n      );\r\n      const totalOptimizedSize = successful.reduce(\r\n        (sum, r) => sum + r.optimizedSize,\r\n        0,\r\n      );\r\n      const averageReduction =\r\n        successful.length > 0\r\n          ? successful.reduce((sum, r) => sum + r.reductionPercentage, 0) /\r\n            successful.length\r\n          : 0;\r\n\r\n      this.logger.log(\r\n        `Batch optimization complete: ${successful.length}/${files.length} successful, ` +\r\n          `${(totalOriginalSize / 1024).toFixed(1)}KB → ${(totalOptimizedSize / 1024).toFixed(1)}KB ` +\r\n          `(${averageReduction.toFixed(1)}% average reduction)`,\r\n      );\r\n    } catch (error) {\r\n      this.logger.error(\r\n        `Failed to optimize directory ${directoryPath}: ${error.message}`,\r\n      );\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Optimize all images in the uploads folder\r\n   */\r\n  async optimizeAllUploads(\r\n    options: OptimizationOptions = {},\r\n  ): Promise<OptimizationResult[]> {\r\n    const uploadsPath = 'uploads';\r\n\r\n    if (!(await fs.pathExists(uploadsPath))) {\r\n      this.logger.warn('Uploads directory does not exist');\r\n      return [];\r\n    }\r\n\r\n    this.logger.log('Starting optimization of all uploads...');\r\n    return await this.optimizeDirectory(uploadsPath, options, true);\r\n  }\r\n\r\n  /**\r\n   * Get supported image formats\r\n   */\r\n  getSupportedFormats(): string[] {\r\n    return ['jpg', 'jpeg', 'png', 'webp', 'avif', 'JPG', 'JPEG', 'PNG', 'WEBP'];\r\n  }\r\n\r\n  /**\r\n   * Check if a file is a supported image format\r\n   */\r\n  isSupportedImage(filename: string): boolean {\r\n    const ext = path.extname(filename).toLowerCase().slice(1);\r\n    return this.getSupportedFormats().includes(ext);\r\n  }\r\n}\r\n"],"names":["ImageOptimizationService","optimizeImage","inputPath","outputPath","options","opts","defaultOptions","relativePath","path","relative","backupPath","join","optimizedPath","finalOutputPath","fs","ensureDir","dirname","copy","originalStats","stat","originalSize","size","image","sharp","metadata","width","height","processedImage","format","jpeg","quality","progressive","mozjpeg","png","compressionLevel","webp","effort","avif","toFile","optimizedStats","optimizedSize","reductionPercentage","logger","log","basename","toFixed","originalPath","success","error","message","optimizeBuffer","buffer","toBuffer","optimizeDirectory","directoryPath","recursive","results","findImageFiles","dir","files","items","readdir","item","fullPath","isDirectory","subFiles","push","isFile","ext","extname","toLowerCase","includes","length","file","result","undefined","successful","filter","r","totalOriginalSize","reduce","sum","totalOptimizedSize","averageReduction","optimizeAllUploads","uploadsPath","pathExists","warn","getSupportedFormats","isSupportedImage","filename","slice","Logger","name"],"mappings":";;;;+BA0BaA;;;eAAAA;;;wBA1BsB;+DACZ;iEACH;8DACE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBf,IAAA,AAAMA,2BAAN,MAAMA;IAQX;;GAEC,GACD,MAAMC,cACJC,SAAiB,EACjBC,UAAmB,EACnBC,UAA+B,CAAC,CAAC,EACJ;QAC7B,MAAMC,OAAO,mBAAK,IAAI,CAACC,cAAc,EAAKF;QAE1C,oDAAoD;QACpD,MAAMG,eAAeC,MAAKC,QAAQ,CAAC,WAAWP;QAC9C,MAAMQ,aAAaF,MAAKG,IAAI,CAAC,kBAAkBJ;QAE/C,gDAAgD;QAChD,MAAMK,gBAAgBJ,MAAKG,IAAI,CAAC,qBAAqBJ;QACrD,MAAMM,kBAAkBV,cAAcS;QAEtC,IAAI;YACF,iDAAiD;YACjD,MAAME,SAAGC,SAAS,CAACP,MAAKQ,OAAO,CAACN;YAChC,MAAMI,SAAGG,IAAI,CAACf,WAAWQ;YAEzB,0BAA0B;YAC1B,MAAMQ,gBAAgB,MAAMJ,SAAGK,IAAI,CAACjB;YACpC,MAAMkB,eAAeF,cAAcG,IAAI;YAEvC,iBAAiB;YACjB,MAAMC,QAAQC,OAAMrB;YAEpB,qBAAqB;YACrB,MAAMsB,WAAW,MAAMF,MAAME,QAAQ;YAErC,yDAAyD;YACzD,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAE,GAAGF;YAE1B,yCAAyC;YACzC,IAAIG,iBAAiBL;YAErB,sCAAsC;YACtC,OAAQjB,KAAKuB,MAAM;gBACjB,KAAK;oBACHD,iBAAiBA,eAAeE,IAAI,CAAC;wBACnCC,SAASzB,KAAKyB,OAAO;wBACrBC,aAAa1B,KAAK0B,WAAW;wBAC7BC,SAAS;oBACX;oBACA;gBACF,KAAK;oBACHL,iBAAiBA,eAAeM,GAAG,CAAC;wBAClCH,SAASzB,KAAKyB,OAAO;wBACrBC,aAAa1B,KAAK0B,WAAW;wBAC7BG,kBAAkB;oBACpB;oBACA;gBACF,KAAK;oBACHP,iBAAiBA,eAAeQ,IAAI,CAAC;wBACnCL,SAASzB,KAAKyB,OAAO;wBACrBM,QAAQ;oBACV;oBACA;gBACF,KAAK;oBACHT,iBAAiBA,eAAeU,IAAI,CAAC;wBACnCP,SAASzB,KAAKyB,OAAO;wBACrBM,QAAQ;oBACV;oBACA;YACJ;YAEA,iCAAiC;YACjC,MAAMtB,SAAGC,SAAS,CAACP,MAAKQ,OAAO,CAACH;YAEhC,2CAA2C;YAC3C,MAAMc,eAAeW,MAAM,CAACzB;YAE5B,2BAA2B;YAC3B,MAAM0B,iBAAiB,MAAMzB,SAAGK,IAAI,CAACN;YACrC,MAAM2B,gBAAgBD,eAAelB,IAAI;YAEzC,MAAMoB,sBACJ,AAAErB,CAAAA,eAAeoB,aAAY,IAAKpB,eAAgB;YAEpD,IAAI,CAACsB,MAAM,CAACC,GAAG,CACb,CAAC,WAAW,EAAEnC,MAAKoC,QAAQ,CAAC1C,WAAW,GAAG,EAAEkB,aAAa,KAAK,EAAEoB,cAAc,IAAI,EAAEC,oBAAoBI,OAAO,CAAC,GAAG,YAAY,CAAC;YAGlI,mEAAmE;YAEnE,OAAO;gBACLzB;gBACAoB;gBACAC;gBACAK,cAAc5C;gBACdU,eAAeC;gBACfH,YAAYA;gBACZqC,SAAS;YACX;QACF,EAAE,OAAOC,OAAO;YACd,IAAI,CAACN,MAAM,CAACM,KAAK,CAAC,CAAC,mBAAmB,EAAE9C,UAAU,EAAE,EAAE8C,MAAMC,OAAO,EAAE;YAErE,2DAA2D;YAE3D,OAAO;gBACL7B,cAAc;gBACdoB,eAAe;gBACfC,qBAAqB;gBACrBK,cAAc5C;gBACdU,eAAeC;gBACfH,YAAYA;gBACZqC,SAAS;gBACTC,OAAOA,MAAMC,OAAO;YACtB;QACF;IACF;IAEA;;GAEC,GACD,MAAMC,eACJC,MAAc,EACd/C,UAA+B,CAAC,CAAC,EAChB;QACjB,MAAMC,OAAO,mBAAK,IAAI,CAACC,cAAc,EAAKF;QAE1C,IAAI;YACF,IAAIuB,iBAAiBJ,OAAM4B;YAE3B,qBAAqB;YACrB,MAAM3B,WAAW,MAAMG,eAAeH,QAAQ;YAE9C,yDAAyD;YACzD,MAAM,EAAEC,KAAK,EAAEC,MAAM,EAAE,GAAGF;YAE1B,yCAAyC;YACzCG,iBAAiBA;YAEjB,sCAAsC;YACtC,OAAQtB,KAAKuB,MAAM;gBACjB,KAAK;oBACHD,iBAAiBA,eAAeE,IAAI,CAAC;wBACnCC,SAASzB,KAAKyB,OAAO;wBACrBC,aAAa1B,KAAK0B,WAAW;wBAC7BC,SAAS;oBACX;oBACA;gBACF,KAAK;oBACHL,iBAAiBA,eAAeM,GAAG,CAAC;wBAClCH,SAASzB,KAAKyB,OAAO;wBACrBC,aAAa1B,KAAK0B,WAAW;wBAC7BG,kBAAkB;oBACpB;oBACA;gBACF,KAAK;oBACHP,iBAAiBA,eAAeQ,IAAI,CAAC;wBACnCL,SAASzB,KAAKyB,OAAO;wBACrBM,QAAQ;oBACV;oBACA;gBACF,KAAK;oBACHT,iBAAiBA,eAAeU,IAAI,CAAC;wBACnCP,SAASzB,KAAKyB,OAAO;wBACrBM,QAAQ;oBACV;oBACA;YACJ;YAEA,OAAO,MAAMT,eAAeyB,QAAQ;QACtC,EAAE,OAAOJ,OAAO;YACd,IAAI,CAACN,MAAM,CAACM,KAAK,CAAC,CAAC,2BAA2B,EAAEA,MAAMC,OAAO,EAAE;YAC/D,MAAMD;QACR;IACF;IAEA;;GAEC,GACD,MAAMK,kBACJC,aAAqB,EACrBlD,UAA+B,CAAC,CAAC,EACjCmD,YAAY,IAAI,EACe;QAC/B,MAAMC,UAAgC,EAAE;QAExC,IAAI;YACF,mDAAmD;YACnD,MAAMC,iBAAiB,OAAOC;gBAC5B,MAAMC,QAAkB,EAAE;gBAC1B,MAAMC,QAAQ,MAAM9C,SAAG+C,OAAO,CAACH;gBAE/B,KAAK,MAAMI,QAAQF,MAAO;oBACxB,MAAMG,WAAWvD,MAAKG,IAAI,CAAC+C,KAAKI;oBAChC,MAAM3C,OAAO,MAAML,SAAGK,IAAI,CAAC4C;oBAE3B,IAAI5C,KAAK6C,WAAW,MAAMT,WAAW;wBACnC,MAAMU,WAAW,MAAMR,eAAeM;wBACtCJ,MAAMO,IAAI,IAAID;oBAChB,OAAO,IAAI9C,KAAKgD,MAAM,IAAI;wBACxB,MAAMC,MAAM5D,MAAK6D,OAAO,CAACP,MAAMQ,WAAW;wBAC1C,IAAI;4BAAC;4BAAQ;4BAAS;4BAAQ;yBAAQ,CAACC,QAAQ,CAACH,MAAM;4BACpDT,MAAMO,IAAI,CAACH;wBACb;oBACF;gBACF;gBAEA,OAAOJ;YACT;YAEA,MAAMA,QAAQ,MAAMF,eAAeH;YACnC,IAAI,CAACZ,MAAM,CAACC,GAAG,CACb,CAAC,MAAM,EAAEgB,MAAMa,MAAM,CAAC,uBAAuB,EAAElB,eAAe;YAGhE,KAAK,MAAMmB,QAAQd,MAAO;gBACxB,MAAMe,SAAS,MAAM,IAAI,CAACzE,aAAa,CAACwE,MAAME,WAAWvE;gBACzDoD,QAAQU,IAAI,CAACQ;YACf;YAEA,cAAc;YACd,MAAME,aAAapB,QAAQqB,MAAM,CAAC,CAACC,IAAMA,EAAE/B,OAAO;YAClD,MAAMgC,oBAAoBH,WAAWI,MAAM,CACzC,CAACC,KAAKH,IAAMG,MAAMH,EAAE1D,YAAY,EAChC;YAEF,MAAM8D,qBAAqBN,WAAWI,MAAM,CAC1C,CAACC,KAAKH,IAAMG,MAAMH,EAAEtC,aAAa,EACjC;YAEF,MAAM2C,mBACJP,WAAWJ,MAAM,GAAG,IAChBI,WAAWI,MAAM,CAAC,CAACC,KAAKH,IAAMG,MAAMH,EAAErC,mBAAmB,EAAE,KAC3DmC,WAAWJ,MAAM,GACjB;YAEN,IAAI,CAAC9B,MAAM,CAACC,GAAG,CACb,CAAC,6BAA6B,EAAEiC,WAAWJ,MAAM,CAAC,CAAC,EAAEb,MAAMa,MAAM,CAAC,aAAa,CAAC,GAC9E,GAAG,AAACO,CAAAA,oBAAoB,IAAG,EAAGlC,OAAO,CAAC,GAAG,KAAK,EAAE,AAACqC,CAAAA,qBAAqB,IAAG,EAAGrC,OAAO,CAAC,GAAG,GAAG,CAAC,GAC3F,CAAC,CAAC,EAAEsC,iBAAiBtC,OAAO,CAAC,GAAG,oBAAoB,CAAC;QAE3D,EAAE,OAAOG,OAAO;YACd,IAAI,CAACN,MAAM,CAACM,KAAK,CACf,CAAC,6BAA6B,EAAEM,cAAc,EAAE,EAAEN,MAAMC,OAAO,EAAE;QAErE;QAEA,OAAOO;IACT;IAEA;;GAEC,GACD,MAAM4B,mBACJhF,UAA+B,CAAC,CAAC,EACF;QAC/B,MAAMiF,cAAc;QAEpB,IAAI,CAAE,MAAMvE,SAAGwE,UAAU,CAACD,cAAe;YACvC,IAAI,CAAC3C,MAAM,CAAC6C,IAAI,CAAC;YACjB,OAAO,EAAE;QACX;QAEA,IAAI,CAAC7C,MAAM,CAACC,GAAG,CAAC;QAChB,OAAO,MAAM,IAAI,CAACU,iBAAiB,CAACgC,aAAajF,SAAS;IAC5D;IAEA;;GAEC,GACDoF,sBAAgC;QAC9B,OAAO;YAAC;YAAO;YAAQ;YAAO;YAAQ;YAAQ;YAAO;YAAQ;YAAO;SAAO;IAC7E;IAEA;;GAEC,GACDC,iBAAiBC,QAAgB,EAAW;QAC1C,MAAMtB,MAAM5D,MAAK6D,OAAO,CAACqB,UAAUpB,WAAW,GAAGqB,KAAK,CAAC;QACvD,OAAO,IAAI,CAACH,mBAAmB,GAAGjB,QAAQ,CAACH;IAC7C;;aA5RiB1B,SAAS,IAAIkD,cAAM,CAAC5F,yBAAyB6F,IAAI;aACjDvF,iBAAsC;YACrDwB,SAAS;YACTF,QAAQ;YACRG,aAAa;QACf;;AAwRF"}