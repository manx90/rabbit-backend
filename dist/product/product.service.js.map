{"version":3,"sources":["../../src/product/product.service.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\r\n/* eslint-disable prettier/prettier */\r\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\r\nimport { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { PublishState } from 'src/common/interfaces/entity.interface';\r\nimport { Repository, Between } from 'typeorm';\r\nimport { product, Season } from './entities/product.entity';\r\n@Injectable()\r\nexport class ProductService {\r\n  constructor(\r\n    @InjectRepository(product)\r\n    private readonly productRepo: Repository<product>,\r\n  ) {}\r\n\r\n  async UpdateStatus(id: number): Promise<product> {\r\n    const prod = await this.productRepo.findOne({ where: { id } });\r\n    if (!prod) {\r\n      throw new Error('Product not found');\r\n    }\r\n    console.log('Current publishState:', prod.publishState);\r\n    if (prod.publishState === PublishState.PUBLISHED) {\r\n      prod.publishState = PublishState.DRAFT;\r\n    } else {\r\n      prod.publishState = PublishState.PUBLISHED;\r\n    }\r\n    // Set flag to indicate this is a manual state change (only if column exists)\r\n    if (prod.hasOwnProperty('isManualPublishState')) {\r\n      prod.isManualPublishState = true;\r\n    }\r\n    console.log('New publishState:', prod.publishState);\r\n    await this.productRepo.save(prod);\r\n    return prod;\r\n  }\r\n\r\n  async ShowSeason(season: any): Promise<number> {\r\n    // Find all products with the given season\r\n    const products = await this.productRepo.find({ where: { season: season } });\r\n    if (!products || products.length === 0) {\r\n      return 0;\r\n    }\r\n    for (const prod of products) {\r\n      prod.publishState = PublishState.PUBLISHED;\r\n      if (prod.hasOwnProperty('isManualPublishState')) {\r\n        prod.isManualPublishState = true;\r\n      }\r\n      const newProd = await this.productRepo.save(prod);\r\n      console.log(newProd);\r\n    }\r\n    return products.length;\r\n  }\r\n  async HiddenSeason(season: any): Promise<number> {\r\n    // Find all products with the given season\r\n    const products = await this.productRepo.find({ where: { season: season } });\r\n    if (!products || products.length === 0) {\r\n      return 0;\r\n    }\r\n    for (const prod of products) {\r\n      prod.publishState = PublishState.DRAFT;\r\n      if (prod.hasOwnProperty('isManualPublishState')) {\r\n        prod.isManualPublishState = true;\r\n      }\r\n      await this.productRepo.save(prod);\r\n    }\r\n    return products.length;\r\n  }\r\n\r\n  // ========== STATISTICS FUNCTIONS ==========\r\n\r\n  /**\r\n   * Get total count of all products\r\n   */\r\n  async getTotalProductsCount(): Promise<number> {\r\n    return await this.productRepo.count();\r\n  }\r\n\r\n  /**\r\n   * Get count of products by publish state\r\n   */\r\n  async getProductsCountByPublishState(): Promise<{\r\n    published: number;\r\n    draft: number;\r\n    total: number;\r\n  }> {\r\n    const [published, draft, total] = await Promise.all([\r\n      this.productRepo.count({\r\n        where: { publishState: PublishState.PUBLISHED },\r\n      }),\r\n      this.productRepo.count({ where: { publishState: PublishState.DRAFT } }),\r\n      this.productRepo.count(),\r\n    ]);\r\n\r\n    return { published, draft, total };\r\n  }\r\n\r\n  /**\r\n   * Get count of products by season\r\n   */\r\n  async getProductsCountBySeason(): Promise<{\r\n    winter: number;\r\n    summer: number;\r\n    spring_autumn: number;\r\n    all: number;\r\n    total: number;\r\n  }> {\r\n    const [winter, summer, spring_autumn, all, total] = await Promise.all([\r\n      this.productRepo.count({ where: { season: Season.winter } }),\r\n      this.productRepo.count({ where: { season: Season.summer } }),\r\n      this.productRepo.count({ where: { season: Season.spring_autumn } }),\r\n      this.productRepo.count({ where: { season: Season.all } }),\r\n      this.productRepo.count(),\r\n    ]);\r\n\r\n    return { winter, summer, spring_autumn, all, total };\r\n  }\r\n\r\n  /**\r\n   * Get count of products by special flags\r\n   */\r\n  async getProductsCountByFlags(): Promise<{\r\n    featured: number;\r\n    trending: number;\r\n    new: number;\r\n    bestSeller: number;\r\n    deleted: number;\r\n  }> {\r\n    const [featured, trending, newProducts, bestSeller, deleted] =\r\n      await Promise.all([\r\n        this.productRepo.count({ where: { isFeatured: true } }),\r\n        this.productRepo.count({ where: { isTrending: true } }),\r\n        this.productRepo.count({ where: { isNew: true } }),\r\n        this.productRepo.count({ where: { isBestSeller: true } }),\r\n        this.productRepo.count({ where: { isDeleted: true } }),\r\n      ]);\r\n\r\n    return { featured, trending, new: newProducts, bestSeller, deleted };\r\n  }\r\n\r\n  /**\r\n   * Get products created in the last N days\r\n   */\r\n  async getProductsCreatedInLastDays(days: number = 30): Promise<number> {\r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n\r\n    return await this.productRepo.count({\r\n      where: {\r\n        createdAt: Between(startDate, new Date()),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get products created by date range\r\n   */\r\n  async getProductsCreatedInDateRange(\r\n    startDate: Date,\r\n    endDate: Date,\r\n  ): Promise<number> {\r\n    return await this.productRepo.count({\r\n      where: {\r\n        createdAt: Between(startDate, endDate),\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get products count by category\r\n   */\r\n  async getProductsCountByCategory(): Promise<\r\n    Array<{\r\n      categoryId: number;\r\n      categoryName: string;\r\n      count: number;\r\n    }>\r\n  > {\r\n    const result = await this.productRepo\r\n      .createQueryBuilder('product')\r\n      .leftJoin('product.category', 'category')\r\n      .select('category.id', 'categoryId')\r\n      .addSelect('category.name', 'categoryName')\r\n      .addSelect('COUNT(product.id)', 'count')\r\n      .groupBy('category.id, category.name')\r\n      .getRawMany();\r\n\r\n    return result.map((row: any) => ({\r\n      categoryId: parseInt(row.categoryId),\r\n      categoryName: row.categoryName || 'No Category',\r\n      count: parseInt(row.count),\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get products count by subcategory\r\n   */\r\n  async getProductsCountBySubCategory(): Promise<\r\n    Array<{\r\n      subCategoryId: number;\r\n      subCategoryName: string;\r\n      categoryName: string;\r\n      count: number;\r\n    }>\r\n  > {\r\n    const result = await this.productRepo\r\n      .createQueryBuilder('product')\r\n      .leftJoin('product.subCategory', 'subCategory')\r\n      .leftJoin('product.category', 'category')\r\n      .select('subCategory.id', 'subCategoryId')\r\n      .addSelect('subCategory.name', 'subCategoryName')\r\n      .addSelect('category.name', 'categoryName')\r\n      .addSelect('COUNT(product.id)', 'count')\r\n      .groupBy('subCategory.id, subCategory.name, category.name')\r\n      .getRawMany();\r\n\r\n    return result.map((row: any) => ({\r\n      subCategoryId: parseInt(row.subCategoryId),\r\n      subCategoryName: row.subCategoryName || 'No SubCategory',\r\n      categoryName: row.categoryName || 'No Category',\r\n      count: parseInt(row.count),\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get top selling products (by sales count)\r\n   */\r\n  async getTopSellingProducts(limit: number = 10): Promise<\r\n    Array<{\r\n      id: number;\r\n      name: string;\r\n      sales: number;\r\n      totalQuantity: number;\r\n    }>\r\n  > {\r\n    const products = await this.productRepo.find({\r\n      select: ['id', 'name', 'sales', 'quantity'],\r\n      order: { sales: 'DESC' },\r\n      take: limit,\r\n    });\r\n\r\n    return products.map((product) => ({\r\n      id: product.id,\r\n      name: product.name,\r\n      sales: product.sales,\r\n      totalQuantity: product.quantity,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get products with low stock (quantity < threshold)\r\n   */\r\n  async getLowStockProducts(threshold: number = 10): Promise<\r\n    Array<{\r\n      id: number;\r\n      name: string;\r\n      quantity: number;\r\n      season: Season;\r\n    }>\r\n  > {\r\n    const products = await this.productRepo.find({\r\n      select: ['id', 'name', 'quantity', 'season'],\r\n      where: {\r\n        quantity: Between(0, threshold),\r\n        isDeleted: false,\r\n      },\r\n      order: { quantity: 'ASC' },\r\n    });\r\n\r\n    return products.map((product) => ({\r\n      id: product.id,\r\n      name: product.name,\r\n      quantity: product.quantity,\r\n      season: product.season,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get products without images\r\n   */\r\n  async getProductsWithoutImages(): Promise<\r\n    Array<{\r\n      id: number;\r\n      name: string;\r\n      hasCover: boolean;\r\n      hasImages: boolean;\r\n      hasSizeChart: boolean;\r\n      hasMeasure: boolean;\r\n    }>\r\n  > {\r\n    const products = await this.productRepo.find({\r\n      select: [\r\n        'id',\r\n        'name',\r\n        'imgCover',\r\n        'images',\r\n        'imgSizeChart',\r\n        'imgMeasure',\r\n      ],\r\n    });\r\n\r\n    return products\r\n      .filter(\r\n        (product) =>\r\n          !product.imgCover ||\r\n          !product.images ||\r\n          product.images.length === 0 ||\r\n          !product.imgSizeChart ||\r\n          !product.imgMeasure,\r\n      )\r\n      .map((product) => ({\r\n        id: product.id,\r\n        name: product.name,\r\n        hasCover: !!product.imgCover,\r\n        hasImages: !!(product.images && product.images.length > 0),\r\n        hasSizeChart: !!product.imgSizeChart,\r\n        hasMeasure: !!product.imgMeasure,\r\n      }));\r\n  }\r\n\r\n  /**\r\n   * Get average sales per product\r\n   */\r\n  async getAverageSalesPerProduct(): Promise<{\r\n    averageSalesPerProduct: number;\r\n    totalProducts: number;\r\n    totalSales: number;\r\n  }> {\r\n    const [totalProducts, totalSalesRaw] = await Promise.all([\r\n      this.getTotalProductsCount(),\r\n      this.productRepo\r\n        .createQueryBuilder('product')\r\n        .select('SUM(product.sales)', 'totalSales')\r\n        .getRawOne(),\r\n    ]);\r\n\r\n    const totalSales = parseInt(totalSalesRaw?.totalSales || '0');\r\n    const average = totalProducts > 0 ? totalSales / totalProducts : 0;\r\n    return {\r\n      averageSalesPerProduct: Math.round(average * 100) / 100,\r\n      totalProducts,\r\n      totalSales,\r\n    };\r\n  }\r\n  /**\r\n   * Get comprehensive product statistics\r\n   */\r\n  async getComprehensiveStats(): Promise<{\r\n    totalProducts: number;\r\n    publishStateStats: {\r\n      published: number;\r\n      draft: number;\r\n      total: number;\r\n    };\r\n    seasonStats: {\r\n      winter: number;\r\n      summer: number;\r\n      spring_autumn: number;\r\n      all: number;\r\n      total: number;\r\n    };\r\n    flagStats: {\r\n      featured: number;\r\n      trending: number;\r\n      new: number;\r\n      bestSeller: number;\r\n      deleted: number;\r\n    };\r\n    recentStats: {\r\n      last7Days: number;\r\n      last30Days: number;\r\n      last90Days: number;\r\n    };\r\n    recentChange: {\r\n      last7Days: { current: number; previous: number; percentChange: number };\r\n      last30Days: { current: number; previous: number; percentChange: number };\r\n      last90Days: { current: number; previous: number; percentChange: number };\r\n    };\r\n    categoryStats: Array<{\r\n      categoryId: number;\r\n      categoryName: string;\r\n      count: number;\r\n    }>;\r\n    topSelling: Array<{\r\n      id: number;\r\n      name: string;\r\n      sales: number;\r\n      totalQuantity: number;\r\n    }>;\r\n    lowStock: Array<{\r\n      id: number;\r\n      name: string;\r\n      quantity: number;\r\n      season: Season;\r\n    }>;\r\n    missingImages: number;\r\n    salesStats: {\r\n      totalSales: number;\r\n      totalRevenue: number;\r\n      averageSalesPerProduct: number;\r\n      bestSellingProduct: {\r\n        id: number;\r\n        name: string;\r\n        sales: number;\r\n      } | null;\r\n      salesByCategory: Array<{\r\n        categoryId: number;\r\n        categoryName: string;\r\n        totalSales: number;\r\n        productCount: number;\r\n      }>;\r\n    };\r\n  }> {\r\n    const [\r\n      totalProducts,\r\n      publishStateStats,\r\n      seasonStats,\r\n      flagStats,\r\n      last7Days,\r\n      last30Days,\r\n      last90Days,\r\n      categoryStats,\r\n      topSelling,\r\n      lowStock,\r\n      productsWithoutImages,\r\n      salesStats,\r\n    ] = await Promise.all([\r\n      this.getTotalProductsCount(),\r\n      this.getProductsCountByPublishState(),\r\n      this.getProductsCountBySeason(),\r\n      this.getProductsCountByFlags(),\r\n      this.getProductsCreatedInLastDays(7),\r\n      this.getProductsCreatedInLastDays(30),\r\n      this.getProductsCreatedInLastDays(90),\r\n      this.getProductsCountByCategory(),\r\n      this.getTopSellingProducts(5),\r\n      this.getLowStockProducts(10),\r\n      this.getProductsWithoutImages(),\r\n      this.getSalesStatistics(),\r\n    ]);\r\n\r\n    return {\r\n      totalProducts,\r\n      publishStateStats,\r\n      seasonStats,\r\n      flagStats,\r\n      recentStats: {\r\n        last7Days,\r\n        last30Days,\r\n        last90Days,\r\n      },\r\n      categoryStats,\r\n      topSelling,\r\n      lowStock,\r\n      missingImages: productsWithoutImages.length,\r\n      salesStats,\r\n      recentChange: {\r\n        last7Days: await this.getPeriodChange(7),\r\n        last30Days: await this.getPeriodChange(30),\r\n        last90Days: await this.getPeriodChange(90),\r\n      },\r\n    };\r\n  }\r\n\r\n  private async getPeriodChange(days: number): Promise<{\r\n    current: number;\r\n    previous: number;\r\n    percentChange: number;\r\n  }> {\r\n    const now = new Date();\r\n    const startCurrent = new Date();\r\n    startCurrent.setDate(now.getDate() - days);\r\n    const startPrevious = new Date();\r\n    startPrevious.setDate(startCurrent.getDate() - days);\r\n\r\n    const [current, previous] = await Promise.all([\r\n      this.productRepo.count({\r\n        where: { createdAt: Between(startCurrent, now) },\r\n      }),\r\n      this.productRepo.count({\r\n        where: { createdAt: Between(startPrevious, startCurrent) },\r\n      }),\r\n    ]);\r\n\r\n    const percentChange =\r\n      previous === 0\r\n        ? current > 0\r\n          ? 100\r\n          : 0\r\n        : ((current - previous) / previous) * 100;\r\n\r\n    return {\r\n      current,\r\n      previous,\r\n      percentChange: Math.round(percentChange * 100) / 100,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get products count by creator (poster)\r\n   */\r\n  async getProductsCountByCreator(): Promise<\r\n    Array<{\r\n      posterId: string;\r\n      username: string;\r\n      count: number;\r\n    }>\r\n  > {\r\n    const result = await this.productRepo\r\n      .createQueryBuilder('product')\r\n      .leftJoin('product.poster', 'auth')\r\n      .select('auth.id', 'posterId')\r\n      .addSelect('auth.username', 'username')\r\n      .addSelect('COUNT(product.id)', 'count')\r\n      .groupBy('auth.id, auth.username')\r\n      .getRawMany();\r\n\r\n    return result.map((row: any) => ({\r\n      posterId: row.posterId || 'Unknown',\r\n      username: row.username || 'Unknown User',\r\n      count: parseInt(row.count),\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get products with scheduled publishing\r\n   */\r\n  async getScheduledProducts(): Promise<\r\n    Array<{\r\n      id: number;\r\n      name: string;\r\n      datePublished: Date;\r\n      publishState: PublishState;\r\n    }>\r\n  > {\r\n    const products = await this.productRepo.find({\r\n      select: ['id', 'name', 'datePublished', 'publishState'],\r\n      where: {\r\n        datePublished: Between(\r\n          new Date(),\r\n          new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),\r\n        ), // Next year\r\n      },\r\n      order: { datePublished: 'ASC' },\r\n    });\r\n\r\n    return products.map((product) => ({\r\n      id: product.id,\r\n      name: product.name,\r\n      datePublished: product.datePublished,\r\n      publishState: product.publishState,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive sales statistics\r\n   */\r\n  async getSalesStatistics(): Promise<{\r\n    totalSales: number;\r\n    totalRevenue: number;\r\n    averageSalesPerProduct: number;\r\n    bestSellingProduct: {\r\n      id: number;\r\n      name: string;\r\n      sales: number;\r\n    } | null;\r\n    salesByCategory: Array<{\r\n      categoryId: number;\r\n      categoryName: string;\r\n      totalSales: number;\r\n      productCount: number;\r\n    }>;\r\n  }> {\r\n    // Get total sales across all products\r\n    const totalSalesResult = await this.productRepo\r\n      .createQueryBuilder('product')\r\n      .select('SUM(product.sales)', 'totalSales')\r\n      .getRawOne();\r\n\r\n    const totalSales = parseInt(totalSalesResult?.totalSales || '0');\r\n\r\n    // Get total revenue by estimating unit price from sizeDetails (no product.price column)\r\n    // Strategy: for each product, compute the average price across its sizes, then multiply by sales\r\n    const productsForRevenue = await this.productRepo.find({\r\n      select: ['id', 'sales', 'sizeDetails'],\r\n    });\r\n\r\n    const totalRevenue = productsForRevenue.reduce((sum, p) => {\r\n      const sizes = Array.isArray((p as any).sizeDetails)\r\n        ? (p as any).sizeDetails\r\n        : [];\r\n      if (sizes.length === 0 || typeof p.sales !== 'number' || p.sales <= 0)\r\n        return sum;\r\n      const priceValues = sizes\r\n        .map((s: any) =>\r\n          typeof s?.price === 'number' ? s.price : Number(s?.price),\r\n        )\r\n        .filter((v: any) => Number.isFinite(v));\r\n      if (priceValues.length === 0) return sum;\r\n      const avgPrice =\r\n        priceValues.reduce((a: number, b: number) => a + b, 0) /\r\n        priceValues.length;\r\n      return sum + avgPrice * p.sales;\r\n    }, 0);\r\n\r\n    // Get total products count for average calculation\r\n    const totalProducts = await this.getTotalProductsCount();\r\n    const averageSalesPerProduct =\r\n      totalProducts > 0 ? totalSales / totalProducts : 0;\r\n\r\n    // Get best selling product\r\n    const bestSellingProduct = await this.productRepo.findOne({\r\n      select: ['id', 'name', 'sales'],\r\n      where: { sales: Between(1, 999999) }, // Products with at least 1 sale\r\n      order: { sales: 'DESC' },\r\n    });\r\n\r\n    // Get sales by category\r\n    const salesByCategoryResult = await this.productRepo\r\n      .createQueryBuilder('product')\r\n      .leftJoin('product.category', 'category')\r\n      .select('category.id', 'categoryId')\r\n      .addSelect('category.name', 'categoryName')\r\n      .addSelect('SUM(product.sales)', 'totalSales')\r\n      .addSelect('COUNT(product.id)', 'productCount')\r\n      .where('product.sales > 0')\r\n      .groupBy('category.id, category.name')\r\n      .orderBy('totalSales', 'DESC')\r\n      .getRawMany();\r\n\r\n    const salesByCategory = salesByCategoryResult.map((row: any) => ({\r\n      categoryId: parseInt(row.categoryId || '0'),\r\n      categoryName: row.categoryName || 'Uncategorized',\r\n      totalSales: parseInt(row.totalSales || '0'),\r\n      productCount: parseInt(row.productCount || '0'),\r\n    }));\r\n\r\n    return {\r\n      totalSales,\r\n      totalRevenue,\r\n      averageSalesPerProduct: Math.round(averageSalesPerProduct * 100) / 100, // Round to 2 decimal places\r\n      bestSellingProduct: bestSellingProduct\r\n        ? {\r\n            id: bestSellingProduct.id,\r\n            name: bestSellingProduct.name,\r\n            sales: bestSellingProduct.sales,\r\n          }\r\n        : null,\r\n      salesByCategory,\r\n    };\r\n  }\r\n}\r\n"],"names":["ProductService","UpdateStatus","id","prod","productRepo","findOne","where","Error","console","log","publishState","PublishState","PUBLISHED","DRAFT","hasOwnProperty","isManualPublishState","save","ShowSeason","season","products","find","length","newProd","HiddenSeason","getTotalProductsCount","count","getProductsCountByPublishState","published","draft","total","Promise","all","getProductsCountBySeason","winter","summer","spring_autumn","Season","getProductsCountByFlags","featured","trending","newProducts","bestSeller","deleted","isFeatured","isTrending","isNew","isBestSeller","isDeleted","new","getProductsCreatedInLastDays","days","startDate","Date","setDate","getDate","createdAt","Between","getProductsCreatedInDateRange","endDate","getProductsCountByCategory","result","createQueryBuilder","leftJoin","select","addSelect","groupBy","getRawMany","map","row","categoryId","parseInt","categoryName","getProductsCountBySubCategory","subCategoryId","subCategoryName","getTopSellingProducts","limit","order","sales","take","product","name","totalQuantity","quantity","getLowStockProducts","threshold","getProductsWithoutImages","filter","imgCover","images","imgSizeChart","imgMeasure","hasCover","hasImages","hasSizeChart","hasMeasure","getAverageSalesPerProduct","totalProducts","totalSalesRaw","getRawOne","totalSales","average","averageSalesPerProduct","Math","round","getComprehensiveStats","publishStateStats","seasonStats","flagStats","last7Days","last30Days","last90Days","categoryStats","topSelling","lowStock","productsWithoutImages","salesStats","getSalesStatistics","recentStats","missingImages","recentChange","getPeriodChange","now","startCurrent","startPrevious","current","previous","percentChange","getProductsCountByCreator","posterId","username","getScheduledProducts","datePublished","totalSalesResult","productsForRevenue","totalRevenue","reduce","sum","p","sizes","Array","isArray","sizeDetails","priceValues","s","price","Number","v","isFinite","avgPrice","a","b","bestSellingProduct","salesByCategoryResult","orderBy","salesByCategory","productCount","constructor"],"mappings":"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"}