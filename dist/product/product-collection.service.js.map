{"version":3,"sources":["../../src/product/product-collection.service.ts"],"sourcesContent":["import {\n  Injectable,\n  NotFoundException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, In } from 'typeorm';\nimport {\n  ProductCollection,\n  CollectionStatus,\n} from './entities/product-collection.entity';\nimport { product } from './entities/product.entity';\nimport { category, subCategory } from './entities/Category.entity';\nimport {\n  CreateProductCollectionDto,\n  UpdateProductCollectionDto,\n} from './dto/product-collection.dto';\nimport { auth } from 'src/auth/entities/auth.entity';\nimport { Request } from 'express';\nimport { ParsedQs } from 'qs';\nimport { ApiFeatures } from 'src/common/utils/api-features';\n\n@Injectable()\nexport class ProductCollectionService {\n  constructor(\n    @InjectRepository(ProductCollection)\n    private readonly collectionRepo: Repository<ProductCollection>,\n    @InjectRepository(product)\n    private readonly productRepo: Repository<product>,\n    @InjectRepository(category)\n    private readonly categoryRepo: Repository<category>,\n    @InjectRepository(subCategory)\n    private readonly subCategoryRepo: Repository<subCategory>,\n  ) {}\n\n  /**\n   * Create a new product collection with comprehensive validation\n   */\n  async create(\n    createDto: CreateProductCollectionDto,\n    user: auth,\n  ): Promise<ProductCollection> {\n    // Validate and fetch categories\n    let categories: category[] = [];\n    if (createDto.categoryIds && createDto.categoryIds.length > 0) {\n      categories = await this.validateAndFetchCategories(createDto.categoryIds);\n    }\n\n    // Validate and fetch subcategories\n    let subCategories: subCategory[] = [];\n    if (createDto.subCategoryIds && createDto.subCategoryIds.length > 0) {\n      subCategories = await this.validateAndFetchSubCategories(\n        createDto.subCategoryIds,\n        categories,\n      );\n    }\n\n    // Validate and fetch products\n    let products: product[] = [];\n    if (createDto.productIds && createDto.productIds.length > 0) {\n      // Limit to first 10 products\n      const limitedProductIds = createDto.productIds.slice(0, 10);\n      products = await this.validateAndFetchProducts(\n        limitedProductIds,\n        categories,\n        subCategories,\n      );\n    }\n\n    // Validate that at least one of categories, subcategories, or products is provided\n    if (\n      categories.length === 0 &&\n      subCategories.length === 0 &&\n      products.length === 0\n    ) {\n      throw new BadRequestException(\n        'At least one category, subcategory, or product must be provided',\n      );\n    }\n\n    const collection = this.collectionRepo.create({\n      ...createDto,\n      createdBy: user,\n      categories,\n      subCategories,\n      products,\n    });\n\n    // Auto-generate name if not provided\n    if (!createDto.name) {\n      collection.name = await this.generateCollectionName(collection);\n    }\n\n    return await this.collectionRepo.save(collection);\n  }\n\n  /**\n   * Validate and fetch categories\n   */\n  private async validateAndFetchCategories(\n    categoryIds: number[],\n  ): Promise<category[]> {\n    const categories = await this.categoryRepo.find({\n      where: { id: In(categoryIds) },\n    });\n\n    if (categories.length !== categoryIds.length) {\n      const foundIds = categories.map((cat) => cat.id);\n      const missingIds = categoryIds.filter((id) => !foundIds.includes(id));\n      throw new NotFoundException(\n        `Categories with IDs [${missingIds.join(', ')}] not found`,\n      );\n    }\n\n    // Check if all categories are active\n    const inactiveCategories = categories.filter((cat) => !cat.isActive);\n    if (inactiveCategories.length > 0) {\n      const inactiveIds = inactiveCategories.map((cat) => cat.id);\n      throw new BadRequestException(\n        `Categories with IDs [${inactiveIds.join(', ')}] are inactive`,\n      );\n    }\n\n    return categories;\n  }\n\n  /**\n   * Validate and fetch subcategories\n   */\n  private async validateAndFetchSubCategories(\n    subCategoryIds: number[],\n    categories: category[],\n  ): Promise<subCategory[]> {\n    const subCategories = await this.subCategoryRepo.find({\n      where: { id: In(subCategoryIds) },\n      relations: ['category'],\n    });\n\n    if (subCategories.length !== subCategoryIds.length) {\n      const foundIds = subCategories.map((sub) => sub.id);\n      const missingIds = subCategoryIds.filter((id) => !foundIds.includes(id));\n      throw new NotFoundException(\n        `Subcategories with IDs [${missingIds.join(', ')}] not found`,\n      );\n    }\n\n    // Check if all subcategories are active\n    const inactiveSubCategories = subCategories.filter((sub) => !sub.isActive);\n    if (inactiveSubCategories.length > 0) {\n      const inactiveIds = inactiveSubCategories.map((sub) => sub.id);\n      throw new BadRequestException(\n        `Subcategories with IDs [${inactiveIds.join(', ')}] are inactive`,\n      );\n    }\n\n    // Validate relationships with categories if categories are provided\n    if (categories.length > 0) {\n      const categoryIds = categories.map((cat) => cat.id);\n      const invalidSubCategories = subCategories.filter(\n        (sub) => !categoryIds.includes(sub.categoryId),\n      );\n\n      if (invalidSubCategories.length > 0) {\n        const invalidIds = invalidSubCategories.map((sub) => sub.id);\n        const validCategoryIds = categoryIds.join(', ');\n        throw new BadRequestException(\n          `Subcategories with IDs [${invalidIds.join(', ')}] do not belong to any of the specified categories [${validCategoryIds}]`,\n        );\n      }\n    }\n\n    return subCategories;\n  }\n\n  /**\n   * Validate and fetch products\n   */\n  private async validateAndFetchProducts(\n    productIds: number[],\n    categories: category[],\n    subCategories: subCategory[],\n  ): Promise<product[]> {\n    const products = await this.productRepo.find({\n      where: { id: In(productIds) },\n      relations: ['category', 'subCategory'],\n    });\n\n    if (products.length !== productIds.length) {\n      const foundIds = products.map((prod) => prod.id);\n      const missingIds = productIds.filter((id) => !foundIds.includes(id));\n      throw new NotFoundException(\n        `Products with IDs [${missingIds.join(', ')}] not found`,\n      );\n    }\n\n    // Check if all products are not deleted\n    const deletedProducts = products.filter((prod) => prod.isDeleted);\n    if (deletedProducts.length > 0) {\n      const deletedIds = deletedProducts.map((prod) => prod.id);\n      throw new BadRequestException(\n        `Products with IDs [${deletedIds.join(', ')}] are deleted`,\n      );\n    }\n\n    // Validate relationships with categories and subcategories if they are provided\n    if (categories.length > 0 || subCategories.length > 0) {\n      const categoryIds = categories.map((cat) => cat.id);\n      const subCategoryIds = subCategories.map((sub) => sub.id);\n\n      const invalidProducts = products.filter((prod) => {\n        // If categories are specified, product must belong to one of them\n        if (categories.length > 0 && !categoryIds.includes(prod.category.id)) {\n          return true;\n        }\n        // If subcategories are specified, product must belong to one of them\n        if (\n          subCategories.length > 0 &&\n          !subCategoryIds.includes(prod.subCategory.id)\n        ) {\n          return true;\n        }\n        return false;\n      });\n\n      if (invalidProducts.length > 0) {\n        const invalidIds = invalidProducts.map((prod) => prod.id);\n        let errorMessage = `Products with IDs [${invalidIds.join(', ')}] do not belong to the specified `;\n\n        if (categories.length > 0 && subCategories.length > 0) {\n          errorMessage += `categories [${categoryIds.join(', ')}] or subcategories [${subCategoryIds.join(', ')}]`;\n        } else if (categories.length > 0) {\n          errorMessage += `categories [${categoryIds.join(', ')}]`;\n        } else {\n          errorMessage += `subcategories [${subCategoryIds.join(', ')}]`;\n        }\n\n        throw new BadRequestException(errorMessage);\n      }\n    }\n\n    return products;\n  }\n\n  /**\n   * Generate collection name based on categories, subcategories, or products\n   */\n  private async generateCollectionName(\n    collection: ProductCollection,\n  ): Promise<string> {\n    // If single category\n    if (collection.categories && collection.categories.length === 1) {\n      return `${collection.categories[0].name} Collection`;\n    }\n\n    // If single subcategory\n    if (collection.subCategories && collection.subCategories.length === 1) {\n      return `${collection.subCategories[0].name} Collection`;\n    }\n\n    // If single product\n    if (collection.products && collection.products.length === 1) {\n      return `${collection.products[0].name} Collection`;\n    }\n\n    // If multiple categories\n    if (collection.categories && collection.categories.length > 1) {\n      const categoryNames = collection.categories\n        .map((cat) => cat.name)\n        .join(' & ');\n      return `${categoryNames} Collections`;\n    }\n\n    // If multiple subcategories\n    if (collection.subCategories && collection.subCategories.length > 1) {\n      const subCategoryNames = collection.subCategories\n        .map((sub) => sub.name)\n        .join(' & ');\n      return `${subCategoryNames} Collections`;\n    }\n\n    // If multiple products\n    if (collection.products && collection.products.length > 1) {\n      const productNames = collection.products\n        .map((prod) => prod.name)\n        .join(' & ');\n      return `${productNames} Collection`;\n    }\n\n    // If mixed (categories + subcategories + products)\n    const parts: string[] = [];\n\n    if (collection.categories && collection.categories.length > 0) {\n      parts.push(`${collection.categories.length} Categories`);\n    }\n\n    if (collection.subCategories && collection.subCategories.length > 0) {\n      parts.push(`${collection.subCategories.length} Subcategories`);\n    }\n\n    if (collection.products && collection.products.length > 0) {\n      parts.push(`${collection.products.length} Products`);\n    }\n\n    if (parts.length > 0) {\n      return `${parts.join(' + ')} Collection`;\n    }\n\n    // Fallback\n    return 'Custom Collection';\n  }\n\n  /**\n   * Get all collections with pagination and filtering\n   */\n  async getAllCollections(query: ParsedQs): Promise<{\n    status: string;\n    results: number;\n    total: number;\n    currentPage: number;\n    limit: number;\n    totalPages: number;\n    lastPage: number;\n    data: ProductCollection[];\n  }> {\n    const queryBuilder = this.collectionRepo\n      .createQueryBuilder('collection')\n      .leftJoinAndSelect('collection.categories', 'categories')\n      .leftJoinAndSelect('collection.subCategories', 'subCategories')\n      .leftJoinAndSelect('collection.products', 'products')\n      .leftJoinAndSelect('collection.createdBy', 'createdBy')\n      .select([\n        'collection',\n        'categories.id',\n        'categories.name',\n        'subCategories.id',\n        'subCategories.name',\n        'products.id',\n        'products.name',\n        'createdBy.username',\n      ]);\n\n    const features = new ApiFeatures(\n      queryBuilder,\n      query || {},\n      this.collectionRepo.metadata,\n    )\n      .filter()\n      .sort()\n      .paginate();\n\n    const [data, total] = await features.getManyAndCount();\n    const pagination = features.getPaginationInfo();\n\n    // Add product count and sample products to each collection\n    for (const collection of data) {\n      const productCount = await this.getCollectionProductCount(collection);\n      (collection as any).productCount = productCount;\n\n      const sampleProducts = await this.getCollectionSampleProducts(\n        collection,\n        10,\n      );\n      (collection as any).sampleProducts = sampleProducts;\n    }\n\n    return {\n      status: 'success',\n      results: data.length,\n      total,\n      currentPage: pagination.page,\n      limit: pagination.limit,\n      totalPages: Math.ceil(total / pagination.limit),\n      lastPage: Math.ceil(total / pagination.limit),\n      data,\n    };\n  }\n\n  /**\n   * Get a single collection by ID\n   */\n  async findOne(id: number): Promise<ProductCollection> {\n    const collection = await this.collectionRepo.findOne({\n      where: { id },\n      relations: ['categories', 'subCategories', 'products', 'createdBy'],\n    });\n\n    if (!collection) {\n      throw new NotFoundException(`Collection with ID ${id} not found`);\n    }\n\n    // Add product count and sample products\n    const productCount = await this.getCollectionProductCount(collection);\n    (collection as any).productCount = productCount;\n\n    const sampleProducts = await this.getCollectionSampleProducts(\n      collection,\n      5,\n    );\n    (collection as any).sampleProducts = sampleProducts;\n\n    return collection;\n  }\n\n  /**\n   * Update a collection with comprehensive validation\n   */\n  async update(\n    id: number,\n    updateDto: UpdateProductCollectionDto,\n  ): Promise<ProductCollection> {\n    const collection = await this.findOne(id);\n\n    // Update basic fields\n    Object.assign(collection, updateDto);\n\n    // Validate and fetch categories\n    if (updateDto.categoryIds !== undefined) {\n      if (updateDto.categoryIds.length > 0) {\n        const categories = await this.validateAndFetchCategories(\n          updateDto.categoryIds,\n        );\n        collection.categories = categories;\n      } else {\n        collection.categories = [];\n      }\n    }\n\n    // Validate and fetch subcategories\n    if (updateDto.subCategoryIds !== undefined) {\n      if (updateDto.subCategoryIds.length > 0) {\n        const subCategories = await this.validateAndFetchSubCategories(\n          updateDto.subCategoryIds,\n          collection.categories || [],\n        );\n        collection.subCategories = subCategories;\n      } else {\n        collection.subCategories = [];\n      }\n    }\n\n    // Validate and fetch products\n    if (updateDto.productIds !== undefined) {\n      if (updateDto.productIds.length > 0) {\n        // Limit to first 10 products\n        const limitedProductIds = updateDto.productIds.slice(0, 10);\n        const products = await this.validateAndFetchProducts(\n          limitedProductIds,\n          collection.categories || [],\n          collection.subCategories || [],\n        );\n        collection.products = products;\n      } else {\n        collection.products = [];\n      }\n    }\n\n    // Validate that at least one of categories, subcategories, or products is provided\n    if (\n      (collection.categories?.length || 0) === 0 &&\n      (collection.subCategories?.length || 0) === 0 &&\n      (collection.products?.length || 0) === 0\n    ) {\n      throw new BadRequestException(\n        'At least one category, subcategory, or product must be provided',\n      );\n    }\n\n    // Auto-regenerate name if name is not provided and content changed\n    if (\n      !updateDto.name &&\n      (updateDto.categoryIds !== undefined ||\n        updateDto.subCategoryIds !== undefined ||\n        updateDto.productIds !== undefined)\n    ) {\n      collection.name = await this.generateCollectionName(collection);\n    }\n\n    return await this.collectionRepo.save(collection);\n  }\n\n  /**\n   * Delete a collection\n   */\n  async remove(id: number): Promise<void> {\n    const collection = await this.findOne(id);\n    await this.collectionRepo.remove(collection);\n  }\n\n  /**\n   * Get products from a collection (for client API)\n   */\n  async getCollectionProducts(\n    id: number,\n    query: ParsedQs,\n    req?: Request,\n  ): Promise<{\n    status: string;\n    results: number;\n    total: number;\n    currentPage: number;\n    limit: number;\n    totalPages: number;\n    lastPage: number;\n    data: product[];\n    collection: ProductCollection;\n  }> {\n    const collection = await this.findOne(id);\n\n    // Check if collection is active\n    if (collection.status !== CollectionStatus.ACTIVE) {\n      throw new BadRequestException('Collection is not active');\n    }\n\n    // Check validity dates\n    if (collection.metadata?.validFrom && collection.metadata?.validTo) {\n      const now = new Date();\n      const validFrom = new Date(collection.metadata.validFrom);\n      const validTo = new Date(collection.metadata.validTo);\n\n      if (now < validFrom || now > validTo) {\n        throw new BadRequestException('Collection is not valid at this time');\n      }\n    }\n\n    let queryBuilder = this.productRepo\n      .createQueryBuilder('product')\n      .leftJoinAndSelect('product.category', 'category')\n      .leftJoinAndSelect('product.subCategory', 'subCategory')\n      .leftJoinAndSelect('product.poster', 'auth')\n      .select([\n        'product',\n        'category.id',\n        'category.name',\n        'subCategory.name',\n        'subCategory.id',\n        'auth.username',\n      ]);\n\n    // If collection has specific products, show only those\n    if (collection.products && collection.products.length > 0) {\n      const productIds = collection.products.map((prod) => prod.id);\n      queryBuilder = queryBuilder.where('product.id IN (:...productIds)', {\n        productIds,\n      });\n    } else {\n      // If no specific products, show all products from categories/subcategories\n      // Apply collection logic based on type\n      switch (collection.type) {\n        case 'category_based':\n          if (collection.categories && collection.categories.length > 0) {\n            const categoryIds = collection.categories.map((cat) => cat.id);\n            queryBuilder = queryBuilder.where(\n              'category.id IN (:...categoryIds)',\n              { categoryIds },\n            );\n\n            if (collection.settings?.includeSubcategories) {\n              const subCategoryIds =\n                await this.getSubCategoryIdsFromCategories(categoryIds);\n              if (subCategoryIds.length > 0) {\n                queryBuilder = queryBuilder.orWhere(\n                  'subCategory.id IN (:...subCategoryIds)',\n                  { subCategoryIds },\n                );\n              }\n            }\n          }\n          break;\n\n        case 'product_based':\n          // This should not happen since we have products\n          break;\n\n        case 'mixed':\n          const conditions = [];\n          const params = {};\n\n          if (collection.categories && collection.categories.length > 0) {\n            const categoryIds = collection.categories.map((cat) => cat.id);\n            (conditions as string[]).push('category.id IN (:...categoryIds)');\n            (params as Record<string, any>)['categoryIds'] = categoryIds;\n          }\n\n          if (collection.subCategories && collection.subCategories.length > 0) {\n            const subCategoryIds = collection.subCategories.map(\n              (sub) => sub.id,\n            );\n            (conditions as string[]).push(\n              'subCategory.id IN (:...subCategoryIds)',\n            );\n            (params as Record<string, any>)['subCategoryIds'] = subCategoryIds;\n          }\n\n          if (conditions.length > 0) {\n            queryBuilder = queryBuilder.where(\n              `(${conditions.join(' OR ')})`,\n              params,\n            );\n          }\n          break;\n      }\n    }\n\n    // Apply collection settings\n    if (collection.settings?.showOutOfStock === false) {\n      queryBuilder = queryBuilder.andWhere('product.quantity > 0');\n    }\n\n    if (collection.settings?.sortBy) {\n      const sortOrder = collection.settings.sortOrder || 'ASC';\n      queryBuilder = queryBuilder.orderBy(\n        `product.${collection.settings.sortBy}`,\n        sortOrder,\n      );\n    } else {\n      queryBuilder = queryBuilder.orderBy('collection.sortOrder', 'ASC');\n    }\n\n    // Apply API features (pagination, filtering, etc.)\n    const features = new ApiFeatures(\n      queryBuilder,\n      query || {},\n      this.productRepo.metadata,\n    )\n      .filter()\n      .sort()\n      .paginate();\n\n    const [data, total] = await features.getManyAndCount();\n    const pagination = features.getPaginationInfo();\n\n    // Apply max products limit from settings\n    let finalData = data;\n    if (\n      collection.settings?.maxProducts &&\n      finalData.length > collection.settings.maxProducts\n    ) {\n      finalData = finalData.slice(0, collection.settings.maxProducts);\n    }\n\n    // Transform URLs if request object is provided\n    if (req) {\n      finalData = this.transformProductUrls(finalData, req);\n    }\n\n    return {\n      status: 'success',\n      results: finalData.length,\n      total: Math.min(total, collection.settings?.maxProducts || total),\n      currentPage: pagination.page,\n      limit: pagination.limit,\n      totalPages: Math.ceil(\n        Math.min(total, collection.settings?.maxProducts || total) /\n          pagination.limit,\n      ),\n      lastPage: Math.ceil(\n        Math.min(total, collection.settings?.maxProducts || total) /\n          pagination.limit,\n      ),\n      data: finalData,\n      collection: {\n        id: collection.id,\n        name: collection.name,\n        description: collection.description,\n        type: collection.type,\n        status: collection.status,\n        isFeatured: collection.isFeatured,\n        sortOrder: collection.sortOrder,\n        settings: collection.settings,\n        metadata: collection.metadata,\n        createdAt: collection.createdAt,\n        updatedAt: collection.updatedAt,\n      } as ProductCollection,\n    };\n  }\n\n  /**\n   * Get active collections for client API\n   */\n  async getActiveCollections(): Promise<ProductCollection[]> {\n    const collections = await this.collectionRepo.find({\n      where: { status: CollectionStatus.ACTIVE },\n      relations: ['categories', 'subCategories', 'products'],\n      order: {\n        displayPriority: 'DESC',\n        isPriority: 'DESC',\n        sortOrder: 'ASC',\n        createdAt: 'DESC',\n      },\n    });\n\n    // Add product count and sample products to each collection\n    for (const collection of collections) {\n      const productCount = await this.getCollectionProductCount(collection);\n      (collection as any).productCount = productCount;\n\n      // Get first 3 products as sample\n      const sampleProducts = await this.getCollectionSampleProducts(\n        collection,\n        3,\n      );\n      (collection as any).sampleProducts = sampleProducts;\n    }\n\n    return collections;\n  }\n\n  /**\n   * Get collection with its products (paginated)\n   */\n  async getCollectionWithProducts(\n    id: number,\n    page: number = 1,\n    limit: number = 10,\n    req?: Request,\n  ): Promise<{\n    collection: ProductCollection;\n    products: {\n      data: product[];\n      total: number;\n      currentPage: number;\n      totalPages: number;\n      hasMore: boolean;\n    };\n  }> {\n    const collection = await this.findOne(id);\n\n    // Get products for this collection\n    const productsResult = await this.getCollectionProducts(\n      id,\n      { page: page.toString(), limit: limit.toString() },\n      req,\n    );\n\n    return {\n      collection,\n      products: {\n        data: productsResult.data,\n        total: productsResult.total,\n        currentPage: productsResult.currentPage,\n        totalPages: productsResult.totalPages,\n        hasMore: productsResult.currentPage < productsResult.totalPages,\n      },\n    };\n  }\n\n  /**\n   * Get total product count for a collection\n   */\n  private async getCollectionProductCount(\n    collection: ProductCollection,\n  ): Promise<number> {\n    let queryBuilder = this.productRepo.createQueryBuilder('product');\n\n    // If collection has specific products, count only those\n    if (collection.products && collection.products.length > 0) {\n      const productIds = collection.products.map((prod) => prod.id);\n      return await queryBuilder\n        .where('product.id IN (:...productIds)', { productIds })\n        .getCount();\n    }\n\n    // If no specific products, count all products from categories/subcategories\n    const conditions = [];\n    const params = {};\n\n    if (collection.categories && collection.categories.length > 0) {\n      const categoryIds = collection.categories.map((cat) => cat.id);\n      (conditions as string[]).push('product.categoryId IN (:...categoryIds)');\n      (params as Record<string, any>)['categoryIds'] = categoryIds;\n    }\n\n    if (collection.subCategories && collection.subCategories.length > 0) {\n      const subCategoryIds = collection.subCategories.map((sub) => sub.id);\n      (conditions as string[]).push(\n        'product.subCategoryId IN (:...subCategoryIds)',\n      );\n      (params as Record<string, any>)['subCategoryIds'] = subCategoryIds;\n    }\n\n    if (conditions.length > 0) {\n      queryBuilder = queryBuilder.where(`(${conditions.join(' OR ')})`, params);\n    }\n\n    return await queryBuilder.getCount();\n  }\n\n  /**\n   * Get sample products for a collection\n   */\n  private async getCollectionSampleProducts(\n    collection: ProductCollection,\n    limit: number = 10,\n  ): Promise<product[]> {\n    // If collection has specific products, return ONLY those products (no sample)\n    if (collection.products && collection.products.length > 0) {\n      // Return the actual products added to the collection\n      return collection.products.slice(0, limit);\n    }\n\n    // If no specific products, get sample products from categories/subcategories\n    let queryBuilder = this.productRepo\n      .createQueryBuilder('product')\n      .leftJoinAndSelect('product.category', 'category')\n      .leftJoinAndSelect('product.subCategory', 'subCategory')\n      .select([\n        'product.id',\n        'product.name',\n        'product.description',\n        'product.images',\n        'product.imgCover',\n        'product.quantity',\n        'product.sizeDetails',\n        'product.colors',\n        'category.id',\n        'category.name',\n        'subCategory.id',\n        'subCategory.name',\n      ])\n      .limit(limit);\n\n    const conditions = [];\n    const params = {};\n\n    if (collection.categories && collection.categories.length > 0) {\n      const categoryIds = collection.categories.map((cat) => cat.id);\n      (conditions as string[]).push('product.categoryId IN (:...categoryIds)');\n      (params as Record<string, any>)['categoryIds'] = categoryIds;\n    }\n\n    if (collection.subCategories && collection.subCategories.length > 0) {\n      const subCategoryIds = collection.subCategories.map((sub) => sub.id);\n      (conditions as string[]).push(\n        'product.subCategoryId IN (:...subCategoryIds)',\n      );\n      (params as Record<string, any>)['subCategoryIds'] = subCategoryIds;\n    }\n\n    if (conditions.length > 0) {\n      queryBuilder = queryBuilder.where(`(${conditions.join(' OR ')})`, params);\n    }\n\n    return await queryBuilder.getMany();\n  }\n\n  /**\n   * Get priority collections (collections marked as priority)\n   */\n  async getPriorityCollections(): Promise<ProductCollection[]> {\n    return await this.collectionRepo.find({\n      where: {\n        status: CollectionStatus.ACTIVE,\n        isPriority: true,\n      },\n      relations: ['categories', 'subCategories'],\n      order: {\n        displayPriority: 'DESC',\n        sortOrder: 'ASC',\n        createdAt: 'DESC',\n      },\n    });\n  }\n\n  /**\n   * Get collections by priority range\n   */\n  async getCollectionsByPriority(\n    minPriority: number,\n    maxPriority?: number,\n  ): Promise<ProductCollection[]> {\n    const queryBuilder = this.collectionRepo\n      .createQueryBuilder('collection')\n      .leftJoinAndSelect('collection.categories', 'categories')\n      .leftJoinAndSelect('collection.subCategories', 'subCategories')\n      .where('collection.status = :status', {\n        status: CollectionStatus.ACTIVE,\n      });\n\n    if (maxPriority !== undefined) {\n      queryBuilder.andWhere(\n        'collection.displayPriority >= :minPriority AND collection.displayPriority <= :maxPriority',\n        {\n          minPriority,\n          maxPriority,\n        },\n      );\n    } else {\n      queryBuilder.andWhere('collection.displayPriority >= :minPriority', {\n        minPriority,\n      });\n    }\n\n    return await queryBuilder\n      .orderBy('collection.displayPriority', 'DESC')\n      .addOrderBy('collection.sortOrder', 'ASC')\n      .addOrderBy('collection.createdAt', 'DESC')\n      .getMany();\n  }\n\n  /**\n   * Helper method to get subcategory IDs from category IDs\n   */\n  private async getSubCategoryIdsFromCategories(\n    categoryIds: number[],\n  ): Promise<number[]> {\n    const subCategories = await this.subCategoryRepo.find({\n      where: { categoryId: In(categoryIds) },\n      select: ['id'],\n    });\n    return subCategories.map((sub) => sub.id);\n  }\n\n  /**\n   * Transform product file paths to full URLs\n   */\n  private transformProductUrls(products: product[], req: Request): any[] {\n    const protocol = req.protocol || 'http';\n    const host = req.get('host') || 'localhost:3000';\n    const baseUrl = `${protocol}://${host}`;\n\n    return products.map((product) => {\n      const transformed = Object.create(\n        Object.getPrototypeOf(product),\n        Object.getOwnPropertyDescriptors(product),\n      );\n\n      if (transformed.imgCover && !transformed.imgCover.startsWith('http')) {\n        transformed.imgCover = `${baseUrl}/uploads/${transformed.imgCover}`;\n      }\n\n      if (\n        transformed.imgSizeChart &&\n        !transformed.imgSizeChart.startsWith('http')\n      ) {\n        transformed.imgSizeChart = `${baseUrl}/uploads/${transformed.imgSizeChart}`;\n      }\n\n      if (\n        transformed.imgMeasure &&\n        !transformed.imgMeasure.startsWith('http')\n      ) {\n        transformed.imgMeasure = `${baseUrl}/uploads/${transformed.imgMeasure}`;\n      }\n\n      if (transformed.images && Array.isArray(transformed.images)) {\n        transformed.images = transformed.images.map((img: string) =>\n          img && !img.startsWith('http') ? `${baseUrl}/uploads/${img}` : img,\n        );\n      }\n\n      if (transformed.colors && Array.isArray(transformed.colors)) {\n        transformed.colors = transformed.colors.map((color) => ({\n          ...color,\n          imgColor:\n            color.imgColor && !color.imgColor.startsWith('http')\n              ? `${baseUrl}/uploads/${color.imgColor}`\n              : color.imgColor,\n        }));\n      }\n\n      return transformed;\n    });\n  }\n}\n"],"names":["ProductCollectionService","create","createDto","user","categories","categoryIds","length","validateAndFetchCategories","subCategories","subCategoryIds","validateAndFetchSubCategories","products","productIds","limitedProductIds","slice","validateAndFetchProducts","BadRequestException","collection","collectionRepo","createdBy","name","generateCollectionName","save","categoryRepo","find","where","id","In","foundIds","map","cat","missingIds","filter","includes","NotFoundException","join","inactiveCategories","isActive","inactiveIds","subCategoryRepo","relations","sub","inactiveSubCategories","invalidSubCategories","categoryId","invalidIds","validCategoryIds","productRepo","prod","deletedProducts","isDeleted","deletedIds","invalidProducts","category","subCategory","errorMessage","categoryNames","subCategoryNames","productNames","parts","push","getAllCollections","query","queryBuilder","createQueryBuilder","leftJoinAndSelect","select","features","ApiFeatures","metadata","sort","paginate","data","total","getManyAndCount","pagination","getPaginationInfo","productCount","getCollectionProductCount","sampleProducts","getCollectionSampleProducts","status","results","currentPage","page","limit","totalPages","Math","ceil","lastPage","findOne","update","updateDto","Object","assign","undefined","remove","getCollectionProducts","req","CollectionStatus","ACTIVE","validFrom","validTo","now","Date","type","settings","includeSubcategories","getSubCategoryIdsFromCategories","orWhere","conditions","params","showOutOfStock","andWhere","sortBy","sortOrder","orderBy","finalData","maxProducts","transformProductUrls","min","description","isFeatured","createdAt","updatedAt","getActiveCollections","collections","order","displayPriority","isPriority","getCollectionWithProducts","productsResult","toString","hasMore","getCount","getMany","getPriorityCollections","getCollectionsByPriority","minPriority","maxPriority","addOrderBy","protocol","host","get","baseUrl","product","transformed","getPrototypeOf","getOwnPropertyDescriptors","imgCover","startsWith","imgSizeChart","imgMeasure","images","Array","isArray","img","colors","color","imgColor","constructor"],"mappings":"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"}