{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport {\n  Injectable,\n  UnauthorizedException,\n  NotFoundException,\n  BadRequestException,\n  InternalServerErrorException,\n  Logger,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcrypt';\n\nimport { auth } from './entities/auth.entity';\nimport {\n  AuthUser,\n  LoginDto,\n  RegisterDto,\n  ChangePasswordDto,\n} from './dto/auth.dto';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { Role } from '../common/constants/roles.constant';\nimport { AuthRepository } from '../common/Repositories/auth.repository';\nimport { AppConfigService } from '../config/config.service';\n\nexport interface AuthenticatedUser {\n  id: string;\n  username: string;\n  role: string;\n}\n\n@Injectable()\nexport class AuthService {\n  private readonly logger = new Logger(AuthService.name);\n\n  constructor(\n    private readonly authRepository: AuthRepository,\n    private readonly jwtService: JwtService,\n    private readonly configService: AppConfigService,\n  ) {}\n\n  async signUp(registerDto: RegisterDto) {\n    this.logger.log(`Registering user: ${registerDto.username}`);\n    const exists = await this.authRepository.findOne(registerDto.username);\n    if (exists) throw new BadRequestException('Username already exists');\n\n    const userToSave = {\n      ...registerDto,\n    };\n\n    const newUser = await this.authRepository.save(userToSave as AuthUser);\n\n    const payload = {\n      sub: String(newUser.id),\n      username: newUser.username,\n      role: newUser.role,\n    };\n    const access_token = this.jwtService.sign(payload, {\n      secret: this.configService.jwtAccessToken || 'default_secret',\n    });\n\n    const safeUser = this.toSafeUser(newUser);\n    if (!safeUser)\n      throw new InternalServerErrorException('Error creating user');\n    return { access_token, user: safeUser };\n  }\n\n  async logIn(\n    loginDto: LoginDto,\n  ): Promise<{ access_token: string; user: AuthenticatedUser }> {\n    this.logger.log(`Login attempt: ${loginDto.username}`);\n    const user = await this.validateUser(loginDto.username, loginDto.password);\n    if (!user) throw new UnauthorizedException('Invalid username or password');\n\n    const payload = {\n      sub: String(user.id),\n      username: user.username,\n      role: user.role,\n    };\n    const access_token = this.jwtService.sign(payload, {\n      secret: this.configService.jwtAccessToken || 'default_secret',\n    });\n    return { access_token, user };\n  }\n\n  async validateUser(\n    username: string,\n    password: string,\n  ): Promise<AuthenticatedUser | null> {\n    const user = await this.authRepository.findOne(username);\n    if (!user) return null;\n\n    const matches = await bcrypt.compare(password, user.password);\n    if (!matches) return null;\n\n    return this.toSafeUser(user);\n  }\n\n  async createUser(\n    createUserDto: CreateUserDto,\n    creatorId: string,\n  ): Promise<AuthenticatedUser> {\n    const creator = await this.authRepository.findById(creatorId);\n    if (!creator || creator.role !== Role.SuperAdmin) {\n      throw new UnauthorizedException('Only SuperAdmin can create new users');\n    }\n\n    const exists = await this.authRepository.findOne(createUserDto.username);\n    if (exists) {\n      throw new BadRequestException('Username already exists');\n    }\n\n    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);\n\n    const newUser = await this.authRepository.save({\n      username: createUserDto.username,\n      password: hashedPassword,\n      role: createUserDto.role,\n    } as AuthUser);\n\n    const safeUser = this.toSafeUser(newUser);\n    if (!safeUser)\n      throw new InternalServerErrorException('Error creating user');\n    return safeUser;\n  }\n\n  async findById(id: string): Promise<AuthenticatedUser | null> {\n    const user = await this.authRepository.findById(id);\n    return user ? this.toSafeUser(user) : null;\n  }\n\n  async findByUsername(username: string): Promise<AuthenticatedUser | null> {\n    const user = await this.authRepository.findOne(username);\n    return user ? this.toSafeUser(user) : null;\n  }\n\n  async changePassword(\n    userId: string,\n    dto: ChangePasswordDto,\n  ): Promise<{ success: boolean }> {\n    const user = await this.authRepository.findById(userId);\n    if (!user) throw new NotFoundException(`User ${userId} not found`);\n\n    const valid = await this.validateUser(user.username, dto.oldPassword);\n    if (!valid)\n      throw new UnauthorizedException('Current password is incorrect');\n\n    const hashedNewPassword = await bcrypt.hash(dto.newPassword, 10);\n\n    await this.authRepository.updatePassword(userId, hashedNewPassword);\n    return { success: true };\n  }\n\n  async updateUserBySuperAdmin(\n    adminUser: AuthenticatedUser,\n    userId: string,\n    updateUserDto: UpdateUserDto,\n  ): Promise<AuthenticatedUser> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (adminUser.role !== Role.SuperAdmin) {\n      throw new UnauthorizedException(\n        'Only Super Admins can perform this action',\n      );\n    }\n\n    const user = await this.authRepository.findById(userId);\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n\n    if (updateUserDto.password) {\n      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);\n    }\n\n    const updatedUser = await this.authRepository.update(userId, updateUserDto);\n    if (!updatedUser) {\n      throw new InternalServerErrorException('Failed to update user');\n    }\n\n    return this.toSafeUser(updatedUser)!;\n  }\n\n  async getAllUsers(): Promise<AuthenticatedUser[]> {\n    const users = await this.authRepository.getAll();\n    return users\n      .map((u) => this.toSafeUser(u))\n      .filter((u): u is AuthenticatedUser => u !== null);\n  }\n\n  async deleteUser(username: string): Promise<void> {\n    await this.authRepository.deleteOne(username);\n  }\n\n  async deleteAllUsers(): Promise<void> {\n    await this.authRepository.deleteAll();\n    this.logger.warn('All users have been deleted');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async isAdmin(authorization: string): Promise<boolean> {\n    if (!authorization?.startsWith('Bearer ')) return false;\n    try {\n      const token = authorization.slice(7);\n      const payload = this.jwtService.verify<{ role?: string }>(token, {\n        secret: this.configService.jwtAccessToken || 'default_secret',\n      });\n      return payload.role === Role.Admin || payload.role === Role.SuperAdmin;\n    } catch (err: any) {\n      this.logger.warn(`Invalid token: ${err.message}`);\n      return false;\n    }\n  }\n\n  getUserIdFromToken(token: string): string | null {\n    try {\n      const raw = token.startsWith('Bearer ') ? token.slice(7) : token;\n      const decoded = this.jwtService.decode(raw) as { sub?: string };\n      return decoded?.sub || null;\n    } catch (err: any) {\n      this.logger.error(`Error decoding token: ${err.message}`);\n      return null;\n    }\n  }\n\n  private toSafeUser(user: auth | null): AuthenticatedUser | null {\n    if (!user) return null;\n    return {\n      id: user.id,\n      username: user.username,\n      role: user.role,\n    };\n  }\n\n  isLoggedIn(token: string): boolean {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const decoded = this.jwtService.decode(token);\n      return !!decoded;\n    } catch (err: any) {\n      this.logger.error(`Error decoding token: ${err.message}`);\n      return false;\n    }\n  }\n}\n"],"names":["AuthService","signUp","registerDto","logger","log","username","exists","authRepository","findOne","BadRequestException","userToSave","newUser","save","payload","sub","String","id","role","access_token","jwtService","sign","secret","configService","jwtAccessToken","safeUser","toSafeUser","InternalServerErrorException","user","logIn","loginDto","validateUser","password","UnauthorizedException","matches","bcrypt","compare","createUser","createUserDto","creatorId","creator","findById","Role","SuperAdmin","hashedPassword","hash","findByUsername","changePassword","userId","dto","NotFoundException","valid","oldPassword","hashedNewPassword","newPassword","updatePassword","success","updateUserBySuperAdmin","adminUser","updateUserDto","updatedUser","update","getAllUsers","users","getAll","map","u","filter","deleteUser","deleteOne","deleteAllUsers","deleteAll","warn","isAdmin","authorization","startsWith","token","slice","verify","Admin","err","message","getUserIdFromToken","raw","decoded","decode","error","isLoggedIn","constructor","Logger","name"],"mappings":"AAAA,6DAA6D,GAC7D,mEAAmE,GACnE,oDAAoD;;;;+BAgCvCA;;;eAAAA;;;wBAxBN;qBACoB;gEACH;+BAWH;gCACU;+BACE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAS1B,IAAA,AAAMA,cAAN,MAAMA;IASX,MAAMC,OAAOC,WAAwB,EAAE;QACrC,IAAI,CAACC,MAAM,CAACC,GAAG,CAAC,CAAC,kBAAkB,EAAEF,YAAYG,QAAQ,EAAE;QAC3D,MAAMC,SAAS,MAAM,IAAI,CAACC,cAAc,CAACC,OAAO,CAACN,YAAYG,QAAQ;QACrE,IAAIC,QAAQ,MAAM,IAAIG,2BAAmB,CAAC;QAE1C,MAAMC,aAAa,mBACdR;QAGL,MAAMS,UAAU,MAAM,IAAI,CAACJ,cAAc,CAACK,IAAI,CAACF;QAE/C,MAAMG,UAAU;YACdC,KAAKC,OAAOJ,QAAQK,EAAE;YACtBX,UAAUM,QAAQN,QAAQ;YAC1BY,MAAMN,QAAQM,IAAI;QACpB;QACA,MAAMC,eAAe,IAAI,CAACC,UAAU,CAACC,IAAI,CAACP,SAAS;YACjDQ,QAAQ,IAAI,CAACC,aAAa,CAACC,cAAc,IAAI;QAC/C;QAEA,MAAMC,WAAW,IAAI,CAACC,UAAU,CAACd;QACjC,IAAI,CAACa,UACH,MAAM,IAAIE,oCAA4B,CAAC;QACzC,OAAO;YAAER;YAAcS,MAAMH;QAAS;IACxC;IAEA,MAAMI,MACJC,QAAkB,EAC0C;QAC5D,IAAI,CAAC1B,MAAM,CAACC,GAAG,CAAC,CAAC,eAAe,EAAEyB,SAASxB,QAAQ,EAAE;QACrD,MAAMsB,OAAO,MAAM,IAAI,CAACG,YAAY,CAACD,SAASxB,QAAQ,EAAEwB,SAASE,QAAQ;QACzE,IAAI,CAACJ,MAAM,MAAM,IAAIK,6BAAqB,CAAC;QAE3C,MAAMnB,UAAU;YACdC,KAAKC,OAAOY,KAAKX,EAAE;YACnBX,UAAUsB,KAAKtB,QAAQ;YACvBY,MAAMU,KAAKV,IAAI;QACjB;QACA,MAAMC,eAAe,IAAI,CAACC,UAAU,CAACC,IAAI,CAACP,SAAS;YACjDQ,QAAQ,IAAI,CAACC,aAAa,CAACC,cAAc,IAAI;QAC/C;QACA,OAAO;YAAEL;YAAcS;QAAK;IAC9B;IAEA,MAAMG,aACJzB,QAAgB,EAChB0B,QAAgB,EACmB;QACnC,MAAMJ,OAAO,MAAM,IAAI,CAACpB,cAAc,CAACC,OAAO,CAACH;QAC/C,IAAI,CAACsB,MAAM,OAAO;QAElB,MAAMM,UAAU,MAAMC,QAAOC,OAAO,CAACJ,UAAUJ,KAAKI,QAAQ;QAC5D,IAAI,CAACE,SAAS,OAAO;QAErB,OAAO,IAAI,CAACR,UAAU,CAACE;IACzB;IAEA,MAAMS,WACJC,aAA4B,EAC5BC,SAAiB,EACW;QAC5B,MAAMC,UAAU,MAAM,IAAI,CAAChC,cAAc,CAACiC,QAAQ,CAACF;QACnD,IAAI,CAACC,WAAWA,QAAQtB,IAAI,KAAKwB,mBAAI,CAACC,UAAU,EAAE;YAChD,MAAM,IAAIV,6BAAqB,CAAC;QAClC;QAEA,MAAM1B,SAAS,MAAM,IAAI,CAACC,cAAc,CAACC,OAAO,CAAC6B,cAAchC,QAAQ;QACvE,IAAIC,QAAQ;YACV,MAAM,IAAIG,2BAAmB,CAAC;QAChC;QAEA,MAAMkC,iBAAiB,MAAMT,QAAOU,IAAI,CAACP,cAAcN,QAAQ,EAAE;QAEjE,MAAMpB,UAAU,MAAM,IAAI,CAACJ,cAAc,CAACK,IAAI,CAAC;YAC7CP,UAAUgC,cAAchC,QAAQ;YAChC0B,UAAUY;YACV1B,MAAMoB,cAAcpB,IAAI;QAC1B;QAEA,MAAMO,WAAW,IAAI,CAACC,UAAU,CAACd;QACjC,IAAI,CAACa,UACH,MAAM,IAAIE,oCAA4B,CAAC;QACzC,OAAOF;IACT;IAEA,MAAMgB,SAASxB,EAAU,EAAqC;QAC5D,MAAMW,OAAO,MAAM,IAAI,CAACpB,cAAc,CAACiC,QAAQ,CAACxB;QAChD,OAAOW,OAAO,IAAI,CAACF,UAAU,CAACE,QAAQ;IACxC;IAEA,MAAMkB,eAAexC,QAAgB,EAAqC;QACxE,MAAMsB,OAAO,MAAM,IAAI,CAACpB,cAAc,CAACC,OAAO,CAACH;QAC/C,OAAOsB,OAAO,IAAI,CAACF,UAAU,CAACE,QAAQ;IACxC;IAEA,MAAMmB,eACJC,MAAc,EACdC,GAAsB,EACS;QAC/B,MAAMrB,OAAO,MAAM,IAAI,CAACpB,cAAc,CAACiC,QAAQ,CAACO;QAChD,IAAI,CAACpB,MAAM,MAAM,IAAIsB,yBAAiB,CAAC,CAAC,KAAK,EAAEF,OAAO,UAAU,CAAC;QAEjE,MAAMG,QAAQ,MAAM,IAAI,CAACpB,YAAY,CAACH,KAAKtB,QAAQ,EAAE2C,IAAIG,WAAW;QACpE,IAAI,CAACD,OACH,MAAM,IAAIlB,6BAAqB,CAAC;QAElC,MAAMoB,oBAAoB,MAAMlB,QAAOU,IAAI,CAACI,IAAIK,WAAW,EAAE;QAE7D,MAAM,IAAI,CAAC9C,cAAc,CAAC+C,cAAc,CAACP,QAAQK;QACjD,OAAO;YAAEG,SAAS;QAAK;IACzB;IAEA,MAAMC,uBACJC,SAA4B,EAC5BV,MAAc,EACdW,aAA4B,EACA;QAC5B,wEAAwE;QACxE,IAAID,UAAUxC,IAAI,KAAKwB,mBAAI,CAACC,UAAU,EAAE;YACtC,MAAM,IAAIV,6BAAqB,CAC7B;QAEJ;QAEA,MAAML,OAAO,MAAM,IAAI,CAACpB,cAAc,CAACiC,QAAQ,CAACO;QAChD,IAAI,CAACpB,MAAM;YACT,MAAM,IAAIsB,yBAAiB,CAAC;QAC9B;QAEA,IAAIS,cAAc3B,QAAQ,EAAE;YAC1B2B,cAAc3B,QAAQ,GAAG,MAAMG,QAAOU,IAAI,CAACc,cAAc3B,QAAQ,EAAE;QACrE;QAEA,MAAM4B,cAAc,MAAM,IAAI,CAACpD,cAAc,CAACqD,MAAM,CAACb,QAAQW;QAC7D,IAAI,CAACC,aAAa;YAChB,MAAM,IAAIjC,oCAA4B,CAAC;QACzC;QAEA,OAAO,IAAI,CAACD,UAAU,CAACkC;IACzB;IAEA,MAAME,cAA4C;QAChD,MAAMC,QAAQ,MAAM,IAAI,CAACvD,cAAc,CAACwD,MAAM;QAC9C,OAAOD,MACJE,GAAG,CAAC,CAACC,IAAM,IAAI,CAACxC,UAAU,CAACwC,IAC3BC,MAAM,CAAC,CAACD,IAA8BA,MAAM;IACjD;IAEA,MAAME,WAAW9D,QAAgB,EAAiB;QAChD,MAAM,IAAI,CAACE,cAAc,CAAC6D,SAAS,CAAC/D;IACtC;IAEA,MAAMgE,iBAAgC;QACpC,MAAM,IAAI,CAAC9D,cAAc,CAAC+D,SAAS;QACnC,IAAI,CAACnE,MAAM,CAACoE,IAAI,CAAC;IACnB;IAEA,4DAA4D;IAC5D,MAAMC,QAAQC,aAAqB,EAAoB;QACrD,IAAI,EAACA,0BAAAA,oCAAAA,cAAeC,UAAU,CAAC,aAAY,OAAO;QAClD,IAAI;YACF,MAAMC,QAAQF,cAAcG,KAAK,CAAC;YAClC,MAAM/D,UAAU,IAAI,CAACM,UAAU,CAAC0D,MAAM,CAAoBF,OAAO;gBAC/DtD,QAAQ,IAAI,CAACC,aAAa,CAACC,cAAc,IAAI;YAC/C;YACA,OAAOV,QAAQI,IAAI,KAAKwB,mBAAI,CAACqC,KAAK,IAAIjE,QAAQI,IAAI,KAAKwB,mBAAI,CAACC,UAAU;QACxE,EAAE,OAAOqC,KAAU;YACjB,IAAI,CAAC5E,MAAM,CAACoE,IAAI,CAAC,CAAC,eAAe,EAAEQ,IAAIC,OAAO,EAAE;YAChD,OAAO;QACT;IACF;IAEAC,mBAAmBN,KAAa,EAAiB;QAC/C,IAAI;YACF,MAAMO,MAAMP,MAAMD,UAAU,CAAC,aAAaC,MAAMC,KAAK,CAAC,KAAKD;YAC3D,MAAMQ,UAAU,IAAI,CAAChE,UAAU,CAACiE,MAAM,CAACF;YACvC,OAAOC,CAAAA,oBAAAA,8BAAAA,QAASrE,GAAG,KAAI;QACzB,EAAE,OAAOiE,KAAU;YACjB,IAAI,CAAC5E,MAAM,CAACkF,KAAK,CAAC,CAAC,sBAAsB,EAAEN,IAAIC,OAAO,EAAE;YACxD,OAAO;QACT;IACF;IAEQvD,WAAWE,IAAiB,EAA4B;QAC9D,IAAI,CAACA,MAAM,OAAO;QAClB,OAAO;YACLX,IAAIW,KAAKX,EAAE;YACXX,UAAUsB,KAAKtB,QAAQ;YACvBY,MAAMU,KAAKV,IAAI;QACjB;IACF;IAEAqE,WAAWX,KAAa,EAAW;QACjC,IAAI;YACF,mEAAmE;YACnE,MAAMQ,UAAU,IAAI,CAAChE,UAAU,CAACiE,MAAM,CAACT;YACvC,OAAO,CAAC,CAACQ;QACX,EAAE,OAAOJ,KAAU;YACjB,IAAI,CAAC5E,MAAM,CAACkF,KAAK,CAAC,CAAC,sBAAsB,EAAEN,IAAIC,OAAO,EAAE;YACxD,OAAO;QACT;IACF;IA/MAO,YACE,AAAiBhF,cAA8B,EAC/C,AAAiBY,UAAsB,EACvC,AAAiBG,aAA+B,CAChD;aAHiBf,iBAAAA;aACAY,aAAAA;aACAG,gBAAAA;aALFnB,SAAS,IAAIqF,cAAM,CAACxF,YAAYyF,IAAI;IAMlD;AA4ML"}