{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\r\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport {\r\n  Injectable,\r\n  UnauthorizedException,\r\n  NotFoundException,\r\n  BadRequestException,\r\n  InternalServerErrorException,\r\n  Logger,\r\n} from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport * as bcrypt from 'bcrypt';\r\n\r\nimport { auth } from './entities/auth.entity';\r\nimport {\r\n  AuthUser,\r\n  LoginDto,\r\n  RegisterDto,\r\n  ChangePasswordDto,\r\n} from './dto/auth.dto';\r\nimport { CreateUserDto } from './dto/create-user.dto';\r\nimport { UpdateUserDto } from './dto/update-user.dto';\r\nimport { Role } from '../common/constants/roles.constant';\r\nimport { AuthRepository } from '../common/Repositories/auth.repository';\r\nimport { AppConfigService } from '../config/config.service';\r\n\r\nexport interface AuthenticatedUser {\r\n  id: string;\r\n  username: string;\r\n  role: string;\r\n}\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  private readonly logger = new Logger(AuthService.name);\r\n\r\n  constructor(\r\n    private readonly authRepository: AuthRepository,\r\n    private readonly jwtService: JwtService,\r\n    private readonly configService: AppConfigService,\r\n  ) {}\r\n\r\n  async signUp(registerDto: RegisterDto) {\r\n    this.logger.log(`Registering user: ${registerDto.username}`);\r\n    const exists = await this.authRepository.findOne(registerDto.username);\r\n    if (exists) throw new BadRequestException('Username already exists');\r\n\r\n    const userToSave = {\r\n      ...registerDto,\r\n    };\r\n\r\n    const newUser = await this.authRepository.save(userToSave as AuthUser);\r\n\r\n    const payload = {\r\n      sub: String(newUser.id),\r\n      username: newUser.username,\r\n      role: newUser.role,\r\n    };\r\n    const access_token = this.jwtService.sign(payload, {\r\n      secret: this.configService.jwtAccessToken || 'default_secret',\r\n    });\r\n\r\n    const safeUser = this.toSafeUser(newUser);\r\n    if (!safeUser)\r\n      throw new InternalServerErrorException('Error creating user');\r\n    return { access_token, user: safeUser };\r\n  }\r\n\r\n  async logIn(\r\n    loginDto: LoginDto,\r\n  ): Promise<{ access_token: string; user: AuthenticatedUser }> {\r\n    this.logger.log(`Login attempt: ${loginDto.username}`);\r\n    const user = await this.validateUser(loginDto.username, loginDto.password);\r\n    if (!user) throw new UnauthorizedException('Invalid username or password');\r\n\r\n    const payload = {\r\n      sub: String(user.id),\r\n      username: user.username,\r\n      role: user.role,\r\n    };\r\n    const access_token = this.jwtService.sign(payload, {\r\n      secret: this.configService.jwtAccessToken || 'default_secret',\r\n    });\r\n    return { access_token, user };\r\n  }\r\n\r\n  async validateUser(\r\n    username: string,\r\n    password: string,\r\n  ): Promise<AuthenticatedUser | null> {\r\n    const user = await this.authRepository.findOne(username);\r\n    if (!user) return null;\r\n\r\n    const matches = await bcrypt.compare(password, user.password);\r\n    if (!matches) return null;\r\n\r\n    return this.toSafeUser(user);\r\n  }\r\n\r\n  async createUser(\r\n    createUserDto: CreateUserDto,\r\n    creatorId: string,\r\n  ): Promise<AuthenticatedUser> {\r\n    const creator = await this.authRepository.findById(creatorId);\r\n    if (!creator || creator.role !== Role.SuperAdmin) {\r\n      throw new UnauthorizedException('Only SuperAdmin can create new users');\r\n    }\r\n\r\n    const exists = await this.authRepository.findOne(createUserDto.username);\r\n    if (exists) {\r\n      throw new BadRequestException('Username already exists');\r\n    }\r\n\r\n    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);\r\n\r\n    const newUser = await this.authRepository.save({\r\n      username: createUserDto.username,\r\n      password: hashedPassword,\r\n      role: createUserDto.role,\r\n    } as AuthUser);\r\n\r\n    const safeUser = this.toSafeUser(newUser);\r\n    if (!safeUser)\r\n      throw new InternalServerErrorException('Error creating user');\r\n    return safeUser;\r\n  }\r\n\r\n  async findById(id: string): Promise<AuthenticatedUser | null> {\r\n    const user = await this.authRepository.findById(id);\r\n    return user ? this.toSafeUser(user) : null;\r\n  }\r\n\r\n  async findByUsername(username: string): Promise<AuthenticatedUser | null> {\r\n    const user = await this.authRepository.findOne(username);\r\n    return user ? this.toSafeUser(user) : null;\r\n  }\r\n\r\n  async changePassword(\r\n    userId: string,\r\n    dto: ChangePasswordDto,\r\n  ): Promise<{ success: boolean }> {\r\n    const user = await this.authRepository.findById(userId);\r\n    if (!user) throw new NotFoundException(`User ${userId} not found`);\r\n\r\n    const valid = await this.validateUser(user.username, dto.oldPassword);\r\n    if (!valid)\r\n      throw new UnauthorizedException('Current password is incorrect');\r\n\r\n    const hashedNewPassword = await bcrypt.hash(dto.newPassword, 10);\r\n\r\n    await this.authRepository.updatePassword(userId, hashedNewPassword);\r\n    return { success: true };\r\n  }\r\n\r\n  async updateUserBySuperAdmin(\r\n    adminUser: AuthenticatedUser,\r\n    userId: string,\r\n    updateUserDto: UpdateUserDto,\r\n  ): Promise<AuthenticatedUser> {\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\r\n    if (adminUser.role !== Role.SuperAdmin) {\r\n      throw new UnauthorizedException(\r\n        'Only Super Admins can perform this action',\r\n      );\r\n    }\r\n\r\n    const user = await this.authRepository.findById(userId);\r\n    if (!user) {\r\n      throw new NotFoundException('User not found');\r\n    }\r\n\r\n    if (updateUserDto.password) {\r\n      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);\r\n    }\r\n\r\n    const updatedUser = await this.authRepository.update(userId, updateUserDto);\r\n    if (!updatedUser) {\r\n      throw new InternalServerErrorException('Failed to update user');\r\n    }\r\n\r\n    return this.toSafeUser(updatedUser)!;\r\n  }\r\n\r\n  async getAllUsers(): Promise<AuthenticatedUser[]> {\r\n    const users = await this.authRepository.getAll();\r\n    return users\r\n      .map((u) => this.toSafeUser(u))\r\n      .filter((u): u is AuthenticatedUser => u !== null);\r\n  }\r\n\r\n  async deleteUser(username: string): Promise<void> {\r\n    await this.authRepository.deleteOne(username);\r\n  }\r\n\r\n  async deleteAllUsers(): Promise<void> {\r\n    await this.authRepository.deleteAll();\r\n    this.logger.warn('All users have been deleted');\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/require-await\r\n  async isAdmin(authorization: string): Promise<boolean> {\r\n    if (!authorization?.startsWith('Bearer ')) return false;\r\n    try {\r\n      const token = authorization.slice(7);\r\n      const payload = this.jwtService.verify<{ role?: string }>(token, {\r\n        secret: this.configService.jwtAccessToken || 'default_secret',\r\n      });\r\n      return payload.role === Role.Admin || payload.role === Role.SuperAdmin;\r\n    } catch (err: any) {\r\n      this.logger.warn(`Invalid token: ${err.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  getUserIdFromToken(token: string): string | null {\r\n    try {\r\n      const raw = token.startsWith('Bearer ') ? token.slice(7) : token;\r\n      const decoded = this.jwtService.decode(raw) as { sub?: string };\r\n      return decoded?.sub || null;\r\n    } catch (err: any) {\r\n      this.logger.error(`Error decoding token: ${err.message}`);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private toSafeUser(user: auth | null): AuthenticatedUser | null {\r\n    if (!user) return null;\r\n    return {\r\n      id: user.id,\r\n      username: user.username,\r\n      role: user.role,\r\n    };\r\n  }\r\n}\r\n"],"names":["AuthService","signUp","registerDto","logger","log","username","exists","authRepository","findOne","BadRequestException","userToSave","newUser","save","payload","sub","String","id","role","access_token","jwtService","sign","secret","configService","jwtAccessToken","safeUser","toSafeUser","InternalServerErrorException","user","logIn","loginDto","validateUser","password","UnauthorizedException","matches","bcrypt","compare","createUser","createUserDto","creatorId","creator","findById","Role","SuperAdmin","hashedPassword","hash","findByUsername","changePassword","userId","dto","NotFoundException","valid","oldPassword","hashedNewPassword","newPassword","updatePassword","success","updateUserBySuperAdmin","adminUser","updateUserDto","updatedUser","update","getAllUsers","users","getAll","map","u","filter","deleteUser","deleteOne","deleteAllUsers","deleteAll","warn","isAdmin","authorization","startsWith","token","slice","verify","Admin","err","message","getUserIdFromToken","raw","decoded","decode","error","constructor","Logger","name"],"mappings":"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"}