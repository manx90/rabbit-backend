{"version":3,"sources":["../../../src/common/Repositories/auth.repository.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport {\n  Injectable,\n  NotFoundException,\n  InternalServerErrorException,\n  ConflictException,\n  Logger,\n} from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcrypt';\n\nimport { auth } from '../../auth/entities/auth.entity';\nimport { AuthUser } from '../../auth/dto/auth.dto';\nimport { Role } from '../constants/roles.constant';\nimport { UpdateUserDto } from 'src/auth/dto/update-user.dto';\n\n@Injectable()\nexport class AuthRepository {\n  private readonly logger = new Logger(AuthRepository.name);\n\n  constructor(\n    @InjectRepository(auth)\n    private readonly authRepository: Repository<auth>,\n    private readonly jwtService: JwtService,\n  ) {}\n\n  /** Update user by ID */\n  async update(userId: string, updateUserDto: UpdateUserDto): Promise<auth> {\n    const user = await this.findById(userId);\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n\n    // تحديث خصائص المستخدم بالبيانات الجديدة من updateUserDto\n    Object.assign(user, updateUserDto);\n\n    try {\n      return await this.authRepository.save(user);\n    } catch (error: any) {\n      this.logger.error(`Error updating user: ${error.message}`, error.stack);\n      throw new InternalServerErrorException('Failed to update user');\n    }\n  }\n\n  /** Find a user by username */\n  async findOne(username: string): Promise<auth | null> {\n    try {\n      return await this.authRepository.findOne({ where: { username } });\n    } catch (error: any) {\n      this.logger.error(`Error finding user: ${error.message}`, error.stack);\n      throw new InternalServerErrorException('Error finding user');\n    }\n  }\n\n  /** Find a user by ID */\n  async findById(id: string): Promise<auth | null> {\n    try {\n      return await this.authRepository.findOne({ where: { id } });\n    } catch (error: any) {\n      this.logger.error(\n        `Error finding user by ID: ${error.message}`,\n        error.stack,\n      );\n      throw new InternalServerErrorException('Error finding user');\n    }\n  }\n\n  /** Save a new user */\n  async save(user: AuthUser): Promise<auth> {\n    const exists = await this.findOne(user.username);\n    if (exists) {\n      throw new ConflictException('Username already taken');\n    }\n\n    const saltRounds = Number(process.env.SALT) || 10;\n    const hashed = await bcrypt.hash(user.password, saltRounds);\n\n    const entity = new auth();\n    entity.username = user.username;\n    entity.password = hashed;\n    entity.role = user.role ?? Role.Salesman;\n\n    try {\n      return await this.authRepository.save(entity);\n    } catch (error: any) {\n      this.logger.error(`Error saving user: ${error.message}`, error.stack);\n      throw new InternalServerErrorException('Failed to create user');\n    }\n  }\n\n  /** Validate credentials */\n  async validateUser(username: string, password: string): Promise<auth | null> {\n    const user = await this.findOne(username);\n    if (!user) return null;\n    const valid = await bcrypt.compare(password, user.password);\n    return valid ? user : null;\n  }\n\n  /** Generate JWT token */\n  generateToken(user: auth): { access_token: string } {\n    const payload = { username: user.username, sub: user.id, role: user.role };\n    return { access_token: this.jwtService.sign(payload) };\n  }\n\n  /** Update password */\n  async updatePassword(id: string, newPwd: string): Promise<auth> {\n    const user = await this.findById(id);\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    const saltRounds = Number(process.env.SALT) || 10;\n    user.password = await bcrypt.hash(newPwd, saltRounds);\n    return this.authRepository.save(user);\n  }\n\n  /** Delete all users */\n  async deleteAll(): Promise<void> {\n    await this.authRepository.clear();\n  }\n\n  /** Get all users */\n  async getAll(): Promise<auth[]> {\n    return this.authRepository.find();\n  }\n\n  /** Delete one user by username */\n  async deleteOne(username: string): Promise<void> {\n    const user = await this.findOne(username);\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    await this.authRepository.delete({ username });\n  }\n}\n"],"names":["AuthRepository","update","userId","updateUserDto","user","findById","NotFoundException","Object","assign","authRepository","save","error","logger","message","stack","InternalServerErrorException","findOne","username","where","id","exists","ConflictException","saltRounds","Number","process","env","SALT","hashed","bcrypt","hash","password","entity","auth","role","Role","Salesman","validateUser","valid","compare","generateToken","payload","sub","access_token","jwtService","sign","updatePassword","newPwd","deleteAll","clear","getAll","find","deleteOne","delete","constructor","Logger","name"],"mappings":"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"}